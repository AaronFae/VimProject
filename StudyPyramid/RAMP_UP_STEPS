This document is mainly from official site of pyramid: http://docs.pylonsproject.org/projects/pyramid/1.0/index.html, check it out if you can find answer below.

First Pyramid Application:
1. start it:
	~/devenv/bin/python helloworld.py
	OR
	source ~/devenv/bin/activate && python helloworld.py
2. visit it:
	http://localhost:8080/
	http://localhost:8080/goodbye
	http://localhost:8080/hello

Creating a Pyramid Project:
# Before you do anything else, activate virtual python env first:
	source ~/devenv/bin/activate
# Create new project
	paster create -t pyramid_routesalchemy MyProject
# Make sure from now on your working directory is your project folder: MyProject
	cd MyProject
# Install new project for development, this will install a distribution into the python interpreter's library.
	python setup.py develop
# Run test case, the tests are in MyProject/myproject/tests.py
	python setup.py test -q
# Interactive shell, "MyProject" here is the value of section name "app" in development.ini file, see more about pshell in pyramid docs.
	paster pshell development.ini MyProject
# Running the project application
	paster serve development.ini
	OR for development phase:
	paster serve development.ini --reload
	OR for production phase:
	paster serve production.ini
# tar your application:
	python setup.py sdist
	This will tar a .tar.gz file for your application, and make sure all the non-python file types are in your MANIFEST.in file, otherwise, the tar will miss these unspecified file types.
# Modifying Package Structure:
	You can create a new package for example "blog" under "myproject" folder and "cp views.py blog/views.py", and change the "myproject/__init__.py"
	from:
	config.add_view('myproject.views.my_view', renderer='myproject:templates/mytemplate.pt')
	to:
	config.add_view('myproject.views.blog.my_view', renderer='myproject:templates/mytemplate.pt')
# myproject/__init__.py:main function:
	def main(global_config, **settings=settings):
		config = Configurator(root_factory = Root, settings = settings)
		// blablabla
	if you have a "[DEFAULT]" section in development.ini, "global_config" here stores all the key/values pairs in "[DEFAULT]" section.
	"settings" here stores all the key/values pairs in "[app.MyProject]" section in development except one: "use = egg:MyProject"
	 you can put anything you want here into "settings" and access it later from "view callable" by invoking request.registry.setting dictionary at application runtime.

URL dispatch:
	1. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	from myproject.views import myview
	config.add_route('myroute', '/prefix/{one}/{two}', view=myview)
	2. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	config.add_route('myroute', '/prefix/{one}/{two}', view='myproject.views.myview')
# Route pattern syntax:

	pattern: {foo}/bar/baz equals to /{foo}/bar/baz, the slash wil be prepended automatically anyway.

	pattern: foo/{baz}/{bar}
	url: foo/1/2        -> {'baz':u'1', 'bar':u'2'}
	url: foo/abc/def    -> {'baz':u'abc', 'bar':u'def'}
	url: foo/1/2/        -> No match (trailing slash)
	url: bar/abc/def     -> First segment literal mismatch
	And the the matched dict will be availabe as "request.matchdic"

	pattern: foo/{name}.html
	url: /foo/biz.html  -> {'name':u'biz'}

	pattern: foo/{name}.{ext}
	url: /foo/biz.html  -> {'name':u'biz', 'ext':u'html'}

	regular expession pattern: {foo} is actually: {foo:[^/]+} by default so that a replacement markder don't need to be preceded by a / slash, you can also change it to {foo:\d+}

	regular expression pattern: foo/{bar}
	foo/La%20Pe%C3%B1a  -> {'bar':u'La Pe\xf1a'}
	The matchdict will be URL-decoded / UTF-8 decoded.

	If the pattern has a * in it, the name which follows it is considered a “remainder match”. A remainder match must come at the end of the pattern.
	Unlike segment replacement markers, it does not need to be preceded by a slash. For example:
	regular expression pattern: foo/{baz}/{bar}*fizzle
	foo/1/2/           ->	{'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  ->	{'baz':u'abc', 'bar':u'def', 'fizzle':(u'a', u'b', u'c')}

	regular expression way to the similar things for above:
	foo/{baz}/{bar}{fizzle:.*}
	foo/1/2/           -> {'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  -> {'baz':u'abc', 'bar':u'def', 'fizzle': u'a/b/c')}
	This occurs because the default regular expression for a marker is [^/]+ which will match everything up to the first /, while {fizzle:.*} will result in a regular expression match of .* capturing the
remainder into a single value.

# Route Declaration Ordering:
	memebers/{def}
	memebers/abc
	The "memebers/abc" will never be matched, since the ordering will always match the members/{def} first.

# Custom Route Predicates

	info['match'] is useful when predicates need access to the route match. For example:

	def any_of(segment_name, *allowed):
	    def predicate(info, request):
	        if info['match'][segment_name] in allowed:
	            return True
	    return predicate
	num_one_two_or_three = any_of('num', 'one', 'two', 'three')
	config.add_route('num', '/{num}', custom_predicates=(num_one_two_or_three,))
	
	This will ensure the "num" segment here is one of the values one, two or three.

	info['route'] is an object has two useful attributes: name and pattern
	1  def twenty_ten(info, request):
	2      if info['route'].name in ('ymd', 'ym', 'y'):
	3          return info['match']['year'] == '2010'
	4
	5  config.add_route('y', '/{year}', custom_predicates=(twenty_ten,))
	6  config.add_route('ym', '/{year}/{month}', custom_predicates=(twenty_ten,))
	7  config.add_route('ymd', '/{year}/{month}/{day}',
	8                   custom_predicates=(twenty_ten,))
	The above predicate, when added to a number of route configurations ensures that the year match argument is ‘2010’ if and only if the route name is ‘ymd’, ‘ym’, or ‘y’.

# The Matched Route
	The matched route is availabe as "request.matched_route", the useful attribute of this object is the "name" attribute, if no route url pattern matches, request.matched_route is None.

# Route Examples:
	Example 3:
	An example of using a route with a factory:
	config.add_route('idea', 'ideas/{idea}', view='myproject.views.idea_view', factory='myproject.resources.Idea')
	The above route will manufacture an Idea resource as a context, assuming that mypackage.resources.Idea resolves to a class that accepts a request in its __init__. For example:
	class Idea(object):
		def __init__(self, request):
			pass
	In a more complicated application, this root factory might be a class representing a SQLAlchemy model.
	
	Example 4:
	config.add_route('idea', 'site/{id}')
	config.add_view(route_name='idea', view='mypackage.views.site_view')
	are same to
	config.add_route('idea', 'site/{id}', view='mypackage.views.site_view')

# Matching the Root URL
	config.add_route('root', '', view='mypackage.views.root_view')
	Or provide the literal string / as the pattern:
	config.add_route('root', '/', view='mypackage.views.root_view')

# Generating Route URLs

	If you’ve configured a route with the name “foo” and the pattern “{a}/{b}/{c}”, you might do this.

	1 from pyramid.url import route_url
	2 url = route_url('foo', request, a='1', b='2', c='3')

	This would return something like the string http://example.com/1/2/3 (at least if the current protocol and hostname implied http:/example.com).

# Redirecting to Slash-Appended Routes
	config.add_route('hasslash', 'has_slash/', view='myproject.views.has_slash')
	config.add_view(context='pyramid.exceptions.NotFound', view='pyramid.view.append_slash_notfound_view')

	This will make sure the url path like "/has_slash" to be redirect to "/has_slash/"

	If still, when it can't redirect to a slash-appended url, it will go to 404 not found page. In this case, if you want to custom not found view when it can't redirect to a slash-appended url, do this:

	from pyramid.exceptions import NotFound
	from pyramid.view import AppendSlashNotFoundViewFactory

	def notfound_view(context, request):
		return HTTPNotFound('It aint there, stop trying!')

	custom_append_slash = AppendSlashNotFoundViewFactory(notfound_view)
	config.add_view(custom_append_slash, context=NotFound)

# Cleaning Up After a Request:
	
	In mypackage.__init__ module:

	from mypackage.models import DBSession

	from pyramid.events import subscriber
	from pyramid.events import NewRequest

	def cleanup_callback(request):
		DBSession.remove()

	@subscriber(NewRequest)
	def add_cleanup_callback(event):
		event.request.add_finished_callback(cleanup_callback)

	And make sure pyramid.config.Configurator.scan() is called since we have @subscriber here.

# Using Pyramid Security With URL Dispatch
	allow the editor the view permission:
	class Article(object):
		def __init__(self, request):
		   matchdict = request.matchdict
		   article = matchdict.get('article', None)
		   if article == '1':
			   self.__acl__ = [ (Allow, 'editor', 'view') ]

# Debugging Route Matching
	jiawzhang@home-pc:~$ PYRAMID_DEBUG_ROUTEMATCH=true paster server development.ini

# Displaying All Application Routes
	jiawzhang@home-pc:~$ paster proutes development.ini MyProject


Much Ado About Traversal

	It introduce the concepts on "Traversal", "Resource", "View Lookup" and "Use Cases" for Traversal, read it will be helpful for knowing general concept purpose.
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/muchadoabouttraversal.html


Traversal

    Skipped.
	Check it out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/traversal.html


Views


# Defining a View Callable as a Function

	1 from pyramid.response import Response
	2
	3 def hello_world(request):
	4     return Response('Hello world!')

# Defining a View Callable as a Class

	Views defined as classes must have the following traits:
	• an __init__ method that accepts a request argument.
	• a __call__ (or other) method that accepts no parameters and which returns a response.

	1 from pyramid.response import Response
	2
	3 class MyView(object):
	4     def __init__(self, request):
	5         self.request = request
	6
	7     def __call__(self):
	8         return Response('hello')

	If you want to access "context", try "request.context"

# View Callable Responses

	1 from pyramid.response import Response
	2
	3 def view(request):
	4     return Response('OK')

	You don’t need to always use Response to represent a response like HTTPFound in pyramid.httpexceptions can be returned too. A view can actually return any object that has the following attributes.

	status: The HTTP status code (including the name) for the response as a string. E.g. 200 OK or 401 Unauthorized.
	headerlist: A sequence of tuples representing the list of headers that should be set in the response. E.g. [('Content-Type', 'text/html'), ('Content-Length', '412')]
	app_iter: An iterable representing the body of the response. This can be a list, e.g. ['<html><head></head><body>Hello world!</body></html>'] or it can be a file-like object, or any other sort of iterable.

# Using a View Callable to Do an HTTP Redirect

	You can issue an HTTP redirect from within a view by returning a particular kind of response.

	1 from pyramid.httpexceptions import HTTPFound
	2
	3 def myview(request):
	4     return HTTPFound(location='http://example.com')

	All exception types from the pyramid.httpexceptions module implement the Response interface; any can be returned as the response from a view.
	It also includes other response types that imply other HTTP response codes, such as HTTPUnauthorized for 401 Unauthorized.
					
# Using Special Exceptions In View Callables

	Usually when a Python exception is raised within a view callable, Except pyramid.exceptions.NotFound and pyramid.exceptions.Forbidden,
	Pyramid allows all the other exception to propagate all the way out to the WSGI server which invoked the application.
	The two special exceptions accept a single positional constructor argument: a message.
	If NotFound is raised within view code, the result of the Not Found View will be returned to the user agent which performed the request.
	If Forbidden is raised within view code, the result of the Forbidden View will be returned to the user agent which performed the request.
	In all cases, the message provided to the exception constructor is made available to the view which Pyramid invokes as request.exception.args[0].

# Exception Views

	For example, given the following exception class in a module named helloworld.exceptions:

	1 class ValidationFailure(Exception):
	2     def __init__(self, msg):
	3         self.msg = msg

	You can wire a view callable to be called whenever any of your other code raises a hellworld.exceptions.ValidationFailure exception:

	1 from helloworld.exceptions import ValidationFailure
	2
	3 @view_config(context=ValidationFailure)
	4 def failed_validation(exc, request):
	5     response =  Response('Failed validation: %s' % exc.msg)
	6     response.status_int = 500
	7     return response

	This view callable will be invoked whenever a helloworld.exceptions.ValidationError is raised by your application’s view code.

	Other normal view predicates can also be used in combination with an exception view registration:

	1 from pyramid.view import view_config
	2 from pyramid.exceptions import NotFound
	3 from pyramid.httpexceptions import HTTPNotFound
	4
	5 @view_config(context=NotFound, route_name='home')
	6 def notfound_view(request):
	7     return HTTPNotFound()

	The above exception view names the route_name of home, meaning that it will only be called when the route matched has a name of home.

# Handling Form Submissions in View Callables (Unicode and Character Set Issues)

	As an example, let’s assume that the following form page is served up to a browser client, and its action points at some Pyramid view code:

	1 <html xmlns="http://www.w3.org/1999/xhtml">
	2   <head>
	3     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	4   </head>
	5   <form method="POST" action="myview">
	6     <div>
	7       <input type="text" name="firstname"/>
	8     </div>
	9     <div>
	10       <input type="text" name="lastname"/>
	11     </div>
	12     <input type="submit" value="Submit"/>
	13   </form>
	14 </html>

	The values below in the request is converted from UTF-8 to Unicode implicitily.

	1 def myview(request):
	2     firstname = request.params['firstname']
	3     lastname = request.params['lastname']

	So make sure "charset=UTF-8" is always set in HTML head meta tag, otherwise this implicitily convertion will be failed.
	Since this implicitily convertion from UTF-8 to Unicode happens already, don't do this once again like: reqeust.params['firstname'].decode('utf-8')
	This convertion will happen only in reqeust.params, request.GET, request.POST
				 
Renderers

	A view needn’t always return a Response object. If a view happens to return something which does not implement the Pyramid Response interface,
	Pyramid will attempt to use a renderer to construct a response. For example:

	from pyramid.response import Response
	from pyramid.view import view_config

	@view_config(renderer='json')
	def hello_world(request):
		return {'content':'Hello!'}
	
	Means, you should either return a "Reponse" or specify a "renderer" to construct a respose.

# Writing View Callables Which Use a Renderer

	1 config.add_view('myproject.views.my_view', renderer='json')

	Returning "response" will overwrite specifying renderer.
	For example, if your view callable returns an instance of the pyramid.httpexceptions.HTTPFound class as a response, no renderer will be employed.

	1 from pyramid.httpexceptions import HTTPFound
	2
	3 def view(request):
	4     return HTTPFound(location='http://example.com') # any renderer avoided, a http redirect instead.

# Built-In Renderers
	1. string:String Render

	@view_config(renderer='string')
	def hello_world(request):
		return {'content':'Hello!'}

	2. json:JSON Render

	@view_config(renderer='json')
	def hello_world(request):
		return {'content':'Hello!'}
	
	OR

	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='json')
	
	@view_config and config.add_view() are actually same thing.

	
	3. *.pt or *.txt: Chameleon Template Renders

	1) relative path is different from Mako, which means relative to the path which defines the view callable. 
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='templates/foo.pt')

	2) asset specification, same to Mako.
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='myproject:templates/foo.pt')
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='myproject:templates/foo.txt')

	4. *.mak or *.mako: Mako Template Render

	1) relative path(The relative 'foo.mako' below is not relative to the package, but is relative to the directory configured for Mako via the mako.directories configuration file setting.):
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='foo.mako')

	2) asset specification(e.g. apackage:templates/sometemplate.mak):
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='mypackage:templates/foo.mak')

# Varying Attributes of Rendered Responses

	View callables that don’t directly return a response should set these attributes on the request object via setattr during their execution, to influence associated response attributes.
	If return a response directly, you can set attributes on Response object I think, see later.

	response_content_type: Defines the content-type of the resulting response, e.g. text/xml.
	response_headerlist: A sequence of tuples describing cookie values that should be set in the response, e.g. [('Set-Cookie', 'abc=123'), ('X-My-Header', 'foo')].
	response_status: A WSGI-style status code (e.g. 200 OK) describing the status of the response.
	response_charset: The character set (e.g. UTF-8) of the response.
	response_cache_for: A value in seconds which will influence Cache-Control and Expires headers in the returned response. The same can also be achieved by returning various values in the response_headerlist, this is purely a convenience. 

	For example:

	from pyramid.view import view_config

	@view_config(name='gone', renderer='templates/gone.pt')
	def myview(request):
		request.response_status = '404 Not Found'
		return {'URL':request.URL}

# Adding and Changing Renderers
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/renderers.html

# Overriding A Renderer At Runtime
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/renderers.html

Templates

# Using Templates Directly

	In this section, it's actually return Response rather than specifying renderer.

	1 from pyramid.renderers import render_to_response
	2
	3 def sample_view(request):
	4     return render_to_response('mypackage:templates/foo.mako',
	5                               {'foo':1, 'bar':2},
	6                               request=request)

	render_to_response() here is an extension api for the native template api offered by a giving template engine like Chameleon or Mako.

	Or, you can generate string first, then construct the response like below, it's same to above.

	1 from pyramid.renderers import render
	2 from pyramid.response import Response
	3
	4 def sample_view(request):
	5     result = render('mypackage:templates/foo.pt',
	6                     {'foo':1, 'bar':2},
	7                     request=request)
	8     response = Response(result)
	9     return response

	It's also doable to invoke your own 3rd party template Apis in view callable, since you can construct Response like above.
	See more: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/templates.html

	If you want to control more about response, do something like below:
	7     response.content_type = 'text/plain'
	8     response.status_int = 204

# System Values Used During Rendering
	context
	    The current Pyramid context if request was provided as a keyword argument, or None.
	request
		The request provided as a keyword argument.
	renderer_name
		The renderer name used to perform the rendering, e.g. mypackage:templates/foo.pt.
	renderer_info
		An object implementing the pyramid.interfaces.IRendererInfo interface. Basically, an object with the following attributes: name, package and type.
	These variables are made as top-level template variables, you can access them in template by something like ${request}, ${render_info.name}

# Templates Used as Renderers via Configuration

	1 from pyramid.view import view_config
	2
	3 @view_config(renderer='templates/foo.pt')
	4 def my_view(request):
	5     return {'foo':1, 'bar':2}

	This is a better way compared with "# Using Template Directly"
	if you want to do the same thing in "# Using Template Directly" to control more about response, you should set request rather than response, see: "# Varying Attributes of Rendered Responses"

# Templating With Mako Templates

	from pyramid.view import view_config

	@view_config(renderer='foo.mak')
	def my_view(request):
		return {'project':'my project'}

	For the above view callable to work, the following setting needs to be present in the application stanza of your configuration’s ini file:
	mako.directories = mypackage:templates
	And make sure you will have "foo.mak" in your "mypackage:templates" folder, "foo.mak" here is relative to "mypackage:templates" we defined.

# A Sample Mako Template
	 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
	 <html xmlns="http://www.w3.org/1999/xhtml" xmlns:tal="http://xml.zope.org/namespaces/tal">
	 <head>
		 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
		 <title>${project} Application</title>
	 </head>
	   <body>
		  <h1 class="title">Welcome to <code>${project}</code>, an
		   application generated by the <a href="http://docs.pylonsproject.org/projects/pyramid/dev/">pyramid</a> web application framework.</h1>
	   </body>
	 </html>

# Automatically Reloading Templates
	[app:main]
	use = egg:MyProject#app
	reload_templates = true


View Configuration

# View configuration parameters:
	1) non predicate arguments 2) predicate arguments
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/viewconfig.html

# View Configuration Using the @view_config Decorator
	It's a better way compared with imperative configuration for the same purpose.

	An example of the view_config decorator might reside in a Pyramid application module views.py:

	1 from resources import MyResource
	2 from pyramid.view import view_config
	3 from pyramid.response import Response
	4
	5 @view_config(name='my_view', request_method='POST', context=MyResource,
	6              permission='read')
	7 def my_view(request):
	8     return Response('OK')

	Using this decorator as above replaces the need to add this imperative configuration stanza:

	1 config.add_view('.views.my_view', name='my_view', request_method='POST',
	2                 context=MyResource, permission='read')

	All arguments to view_config may be omitted. For example:

	1 from pyramid.response import Response
	2 from pyramid.view import view_config
	3
	4 @view_config()
	5 def my_view(request):
	6     """ My view """
	7     return Response()

	To make Pyramid process your view_config declarations, you must do use the scan method of a Configurator:

	1 # config is assumed to be an instance of the
	2 # pyramid.config.Configurator class
	3 config.scan()

@view_config Placement

	A view_config decorator can be placed in various points in your application.

	If your view callable is a function, it may be used as a function decorator:

	1 from pyramid.view import view_config
	2 from pyramid.response import Response
	3
	4 @view_config(name='edit')
	5 def edit(request):
	6     return Response('edited!')

	If your view callable is a class, the decorator can also be used as a class decorator in Python 2.6 and better (Python 2.5 and below do not support class decorators).

	1 from pyramid.response import Response
	2 from pyramid.view import view_config
    3
	4 @view_config()
	5 class MyView(object):
    6     def __init__(self, request):
    7         self.request = request
	8
	9     def __call__(self):
	10         return Response('hello')

	More than one view_config decorator can be stacked on top of any number of others. Each decorator creates a separate view registration. For example:

	from pyramid.view import view_config
	from pyramid.response import Response

	@view_config(name='edit')
	@view_config(name='change')
	def edit(request):
		    return Response('edited!')

	This registers the same view under two different names.

	The decorator can also be used against class methods:

	 from pyramid.response import Response
	 from pyramid.view import view_config

	 class MyView(object):
		 def __init__(self, request):
			 self.request = request

		 @view_config(name='hello')
		 def amethod(self):
			 return Response('hello')

	The code above is equivalent/same to below, means by default it will invoke __call__ method in class, but add a non-predicate paramter "attr" can specify a method you want to be called,
	when the view callable is invoked.

	from pyramid.response import Response
	from pyramid.view import view_config

	@view_config(attr='amethod', name='hello')
	class MyView(object):
	    def __init__(self, request):
            self.request = request

	    def amethod(self):
	        return Response('hello')

# View Registration Using add_view()

	1 from pyramid.response import Response
	2
	3 def hello_world(request):
	4     return Response('hello!')
	5
	6 # config is assumed to be an instance of the
	7 # pyramid.config.Configurator class
	8 config.add_view(hello_world, name='hello.html')


# Using Resource Interfaces in View Configuration
	I've skipped this portion, since it's traverse/resource/zope related.
	Check it out later: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/viewconfig.html

# Configuring View Security

	1 # config is an instance of pyramid.config.Configurator
	2
	3 config.add_view('myproject.views.add_entry', name='add.html',
	4                 context='myproject.resources.IBlog', permission='add')

	When an authorization policy is enabled, this view will be protected with the add permission.
	The view will not be called if the user does not possess the add permission relative to the current context.
	Instead the forbidden view result will be returned to the client as per Protecting Views with Permissions.
	Question: In Router based pyramid, the context here is always "root" ?

# NotFound Errors:

	Set debug_notfound = True in configuration .ini file will tell you why a view was not found from stderr, and browser representation of the error will include the same information.


Resources
	Skipped.
	Check it out if necessary at http://docs.pylonsproject.org/projects/pyramid/1.0/narr/resources.html#resources-which-implement-interfaces


Static Assets

# Serving Static Assets
	1) absolute path:
	1 # config is an instance of pyramid.config.Configurator
	2 config.add_static_view(name='static', path='/var/www/static')

	In the example above, name is static, and path is /var/www/static.
	In English, this means that you wish to serve the files that live in /var/www/static as sub-URLs of the /static URL prefix. Therefore, the file /var/www/static/foo.css will be
	returned when the user visits your application’s URL /static/foo.css.

	2) asset specification
	1 # config is an instance of pyramid.config.Configurator
	2 config.add_static_view(name='static', path='some_package:a/b/c/static')

	3) "name" argument is a external URL:
	1 # config is an instance of pyramid.config.Configurator
	2 config.add_static_view(name='http://example.com/images',
	3                        path='mypackage:images')
	In this mode, the name is used as the URL prefix when generating a URL using pyramid.url.static_url(). Static assets can be served from external web server.

# Generating Static Asset URLs
	1) URL Prefix way:
	For example, let’s assume you create a set of static declarations like so:

	1 config.add_static_view(name='static1', path='mypackage:assets/1')
	2 config.add_static_view(name='static2', path='mypackage:assets/2')

	You needn’t generate the URLs to static assets “by hand” in such a configuration. Instead, use the static_url() API to generate them for you. For example:

	1 from pyramid.url import static_url
	2 from pyramid.chameleon_zpt import render_template_to_response
	3
	4 def my_view(request):
	5     css_url = static_url('mypackage:assets/1/foo.css', request)
	6     js_url = static_url('mypackage:assets/2/foo.js', request)
	7     return render_template_to_response('templates/my_template.pt',
	8                                        css_url = css_url,
	9                                        js_url = js_url)

	If the request “application URL” of the running system is http://example.com, the css_url generated above would be: http://example.com/static1/foo.css.
	The js_url generated above would be http://example.com/static2/foo.js.

	One benefit of using the static_url() function rather than constructing static URLs “by hand” is that if you need to change the name of a static URL declaration, the generated URLs will continue to resolve properly after the rename.

	2) URL way:
	URLs may also be generated by static_url() to static assets that live outside the Pyramid application(like in apache/nginx side):
	1 config.add_static_view(name='http://example.com/images',
	2                        path='mypackage:images')

	Under such a configuration, the URL generated by static_url for assets which begin with mypackage:images will be prefixed with http://example.com/images:

	1 static_url('mypackage:images/logo.png', request)
	2 # -> http://example.com/images/logo.png

	You can use URL Prefix way in development while URL way in production, set a URL Prefix in development.ini while set a URL in production.ini
	We suggest using the pyramid.registry.Registry.settings API in conjunction with a setting in the application .ini file named like for example "media_location" as the key.

# Advanced: Serving Static Assets Using a View Callable

	Note that you cannot use the static_url() API to generate URLs against assets made accessible by registering a custom static view (for both two cases below).

	1) If you’re using URL dispatch, you may want static assets to only be available as a fallback if no previous route matches.

	Create an instance of the static class inside a static.py file in your application root as below.

	1 from pyramid.view import static
	2 static_view = static('mypackage:static')

	Subsequently, you may wire the files that are served by this view up to be accessible as /<filename> using a configuration method in your application’s startup code.

	1 # .. every other add_route declaration should come
	2 # before this one, as it will, by default, catch all requests
	3
	4 config.add_route('catchall_static', '/*subpath', 'myapp.static.static_view')

	The special name *subpath (see *fizzle for more explanation) above is used by the static view callable to signify the path of the file relative to the directory you’re serving.

    2) Registering A View Callable to Serve a “Static” Asset, for protecting static assets with a permission or can be configured to respond under different circumstances using view predicate arguments.

	1 import os
	2 from webob import Response
	3
	4 def favicon_view(request):
	5     here = os.path.dirname(__file__)
	6     icon = open(os.path.join(here, 'static', 'favicon.ico'))
	7     return Response(content_type='image/x-icon', app_iter=icon)

	You might register such a view via configuration as a view callable that should be called as the result of a traversal:

	1 config.add_view('myapp.views.favicon_view', name='favicon.ico')

	Or you might register it to be the view callable for a particular route:

	1 config.add_route('favicon', '/favicon.ico',
	2                  view='myapp.views.favicon_view')

# Overriding Assets:
	Skipped.
	This feature is something like changing the skin of the site.
	Asset overrides can actually override assets other than templates and static files. 
	Check it out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/assets.html


Request and Response Objects

# Request

	pyramid.request.Request

	req.method:
		The request method, e.g., 'GET', 'POST'
	req.GET:
		A multidict with all the variables in the query string.
	req.POST:
		A multidict with all the variables in the request body. This only has variables if the request was a POST and it is a form submission.
	req.params:
		A multidict with a combination of everything in req.GET and req.POST.
	req.body:
		The contents of the body of the request. This contains the entire request body as a string. This is useful when the request is a POST that is not a form submission, or a request like a PUT. You can also get req.body_file for a file-like object.
	req.cookies:
		A simple dictionary of all the cookies.
	req.headers:
		A dictionary of all the headers. This dictionary is case-insensitive.
	req.urlvars and req.urlargs:
		req.urlvars are the keyword parameters associated with the request URL. req.urlargs are the positional parameters. These are set by products like Routes and Selector.

	Also, for standard HTTP request headers there are usually attributes, for instance: req.accept_language, req.content_length, req.user_agent, as an example. These properties expose the parsed form of each header, for whatever parsing makes sense. For instance, req.if_modified_since returns a datetime object (or None if the header is was not provided).

	In addition to these attributes, there are several ways to get the URL of the request. I’ll show various values for an example URL http://localhost/app/blog?id=10, where the application is mounted at http://localhost/app.

	req.url:
		The full request URL, with query string, e.g., http://localhost/app/blog?id=10
	req.host:
		The host information in the URL, e.g., localhost
	req.host_url:
		The URL with the host, e.g., http://localhost
	req.application_url:
		The URL of the application (just the SCRIPT_NAME portion of the path, not PATH_INFO). E.g., http://localhost/app
	req.path_url:
		The URL of the application including the PATH_INFO. e.g., http://localhost/app/blog
	req.path:
		The URL including PATH_INFO without the host or scheme. e.g., /app/blog
	req.path_qs:
		The URL including PATH_INFO and the query string. e.g, /app/blog?id=10
	req.query_string:
		The query string in the URL, e.g., id=10
	req.relative_url(url, to_application=False):
		Gives a URL, relative to the current URL. If to_application is True, then resolves it relative to req.application_url. 
	
	Methods on Request / Unicode:
	Skipped:
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/webob.html

# Response

	pyramid.response.Response

	response.status:
		The response code plus reason message, like '200 OK'. To set the code without a message, use status_int, i.e.: response.status_int = 200.
	response.headerlist:
		A list of all the headers, like [('Content-Type', 'text/html')]. There’s a case-insensitive multidict in response.headers that also allows you to access these same headers.
	response.app_iter:
		An iterable (such as a list or generator) that will produce the content of the response. This is also accessible as response.body (a string), response.unicode_body (a unicode object, informed by response.charset), and response.body_file (a file-like object; writing to it appends to app_iter).

	Everything else in the object derives from this underlying state. Here’s the highlights:

	response.content_type
		The content type not including the charset parameter. Typical use: response.content_type = 'text/html'.
	response.charset:
		The charset parameter of the content-type, it also informs encoding in response.unicode_body. response.content_type_params is a dictionary of all the parameters.
	response.set_cookie(key, value, max_age=None, path='/', ...):
		Set a cookie. The keyword arguments control the various cookie parameters. The max_age argument is the length for the cookie to live in seconds (you may also use a timedelta object). The Expires key will also be set based on the value of max_age.
	response.delete_cookie(key, path='/', domain=None):
		Delete a cookie from the client. This sets max_age to 0 and the cookie value to ''.
	response.cache_expires(seconds=0):
		This makes this response cacheable for the given number of seconds, or if seconds is 0 then the response is uncacheable (this also sets the Expires header).
	response(environ, start_response):
		The response object is a WSGI application. As an application, it acts according to how you create it. It can do conditional responses if you pass conditional_response=True when instantiating (or set that attribute later). It can also do HEAD and Range requests. 

# Instantiating the Response

	Of course most of the time you just want to make a response. Generally any attribute of the response can be passed in as a keyword argument to the class; e.g.:

	from pyramid.response import Response
	response = Response(body='hello world!', content_type='text/plain')

# Multidict
	?pref=red&pref=blue
	request.GET('pref') => 'blue'
	request.GET.getall('pref') => 'red', 'blue'
	request.GET.getone('pref') => exception, this is no issue only when there is one and only one value for 'pref'
	request.GET.items() => [('pref', 'red'), ('pref', 'blue')]
	request.GET.keys() => ['pref', 'pref'].
	Multidict is a view on a list of tuples; all the keys are ordered, and all the values are ordered.


Sessions

	In order to use sessions, you must set up a session factory during your Pyramid configuration.

	A very basic, insecure sample session factory implementation is provided in the Pyramid core. It uses a cookie to store session information. This implementation has the cookie limitation.

	from pyramid.session import UnencryptedCookieSessionFactoryConfig
	my_session_factory = UnencryptedCookieSessionFactoryConfig('itsaseekreet')

	from pyramid.config import Configurator
	config = Configurator(session_factory = my_session_factory)

	Access session objects:

	from pyramid.response import Response

	def myview(request):
		session = request.session
		if 'abc' in session:
			session['fred'] = 'yes'
		session['abc'] = '123'
		if 'fred' in session:
			return Response('Fred was in the session')
		else:
			return Response('Fred was not in the session')

	You can use a session much like a Python dictionary. It supports all dictionary methods, along with some extra attributes, and methods.

	Extra attributes:

	created
		An integer timestamp indicating the time that this session was created.
	new
		A boolean. If new is True, this session is new. Otherwise, it has been constituted from data that was already serialized.

	Extra methods:

	changed()
		Call this when you mutate a mutable value in the session namespace. See the gotchas below for details on when, and why you should call this.
	invalidate()
		Call this when you want to invalidate the session (dump all data, and – perhaps – set a clearing cookie).

	Some gotchas:

		* Keys and values of session data must be pickleable. This means, typically, that they are instances of basic types of objects, such as strings, lists, dictionaries, tuples, integers, etc.
		* If you place a mutable value (for example, a list or a dictionary) in a session object, and you subsequently mutate that value, you must call the changed() method of the session object.

# Using Alternate Session Factories

	Beaker has support for file-based sessions, database based sessions, and encrypted cookie-based sessions. See http://github.com/Pylons/pyramid_beaker for more information about pyramid_beaker.

# Creating Your Own Session Factory

# Flash Messages

	Two main uses:
	1. To display a status message only once to the user after performing an internal redirect
	2. To allow generic code to log messages for single-time display without having direct access to an HTML template.

	flash(message, queue='', allow_duplicate=True)

	To add a message to a flash message queue, use a session object’s flash() method:

	request.session.flash('mymessage')

	The flash() method appends a message to a flash queue, creating the queue if necessary.

	You can specify a string as queue name, the default one is empty string.

	request.session.flash(msg, 'myappsqueue')

	The allow_duplicate argument defaults to True. If this is False, and you attempt to add a message value which is already present in the queue, it will not be added.

	Using the session.pop_flash Method: this will return the list of the message added, and empty the queue.

	>>> request.session.flash('info message')
	>>> request.session.pop_flash()
	['info message']
	>>> request.session.pop_flash()
	[]

	Using the session.peek_flash Method:

	>>> request.session.flash('info message')
	>>> request.session.peek_flash()
	['info message']
	>>> request.session.peek_flash()
	['info message']
	>>> request.session.pop_flash()
	['info message']
	>>> request.session.peek_flash()
	[]

# Preventing Cross-Site Request Forgery Attacks

	To get the current CSRF token from the session, use the session.get_csrf_token() method.

	token = request.session.get_csrf_token()

	Set it in the hidden tag in html, and post it back to server side for verification.

	token = request.session.get_csrf_token()
	if token != request.POST['csrf_token']:
		raise ValueError('CSRF token did not match')

	Using the session.new_csrf_token Method

	It clears any existing CSRF token, creates a new CSRF token, sets the token into the session, and returns the token.

	token = request.session.new_csrf_token()


Security

# Enabling an Authorization Policy

	By default it's disabled.

# Enabling an Authorization Policy Imperatively

	Since authorization, in general, depends upon authentication, you must enable both them.

	1 from pyramid.config import Configurator
	2 from pyramid.authentication import AuthTktAuthenticationPolicy
	3 from pyramid.authorization import ACLAuthorizationPolicy
	4 authentication_policy = AuthTktAuthenticationPolicy('seekrit')
	5 authorization_policy = ACLAuthorizationPolicy()
	6 config = Configurator(authentication_policy=authentication_policy,
	7                       authorization_policy=authorization_policy)

# Protecting Views with Permissions

	1 # config is an instance of pyramid.config.Configurator
	2
	3 config.add_view('mypackage.views.blog_entry_add_view',
	4                 name='add_entry.html',
	5                 context='mypackage.resources.Blog',
	6                 permission='add')

	The equivalent view registration including the add permission name may be performed via the @view_config decorator:

	1 from pyramid.view import view_config
	2 from resources import Blog
	3
	4 @view_config(context=Blog, name='add_entry.html', permission='add')
	5 def blog_entry_add_view(request):
	6     """ Add blog entry code goes here """
	7     pass

		As a result of any of these various view configuration statements, the requesting user will need to possess the add permission against the context resource in order to be able to invoke the blog_entry_add_view view. If he does not, the Forbidden view will be invoked.

# Setting a Default Permission

	If a permission is not supplied to a view configuration, the registered view will always be executable by entirely anonymous users: any authorization policy in effect is ignored.
	In support of making it easier to configure applications which are “secure by default”, Pyramid allows you to configure a default permission.

	These APIs are in support of configuring a default permission for an application:
    • The default_permission constructor argument to the Configurator constructor.
	• The pyramid.config.Configurator.set_default_permission() method.

	When a default permission is registered:

    • if a view configuration names an explicit permission, the default permission is ignored for that view registration, and the view-configuration-named permission is used.
	• if a view configuration names an explicit permission as the string __no_permission_required__, the default permission is ignored, and the view is registered without a permission.

	Warning

	When you register a default permission, all views (even exception view views) are protected by a permission. For all views which are truly meant to be anonymously accessible, you will need to associate the view’s configuration with the __no_permission_required__ permission.

# Assigning ACLs to your Resource Objects

	For example, an ACL might be attached to the resource for a blog via its class:

	1 from pyramid.security import Everyone
	2 from pyramid.security import Allow
	3
	4 class Blog(object):
	5     __acl__ = [
	6         (Allow, Everyone, 'view'),
	7         (Allow, 'group:editors', 'add'),
	8         (Allow, 'group:editors', 'edit'),
	9         ]

	Or, if your resources are persistent, an ACL might be specified via the __acl__ attribute of an instance of a resource:

	1 from pyramid.security import Everyone
	2 from pyramid.security import Allow
	3
	4 class Blog(object):
	5     pass
	6
	7 blog = Blog()
	8
	9 blog.__acl__ = [
	10         (Allow, Everyone, 'view'),
	11         (Allow, 'group:editors', 'add'),
	12         (Allow, 'group:editors', 'edit'),
	13         ]

# Elements of an ACL

	1 from pyramid.security import Everyone
	2 from pyramid.security import Allow
	3 from pyramid.security import Deny
	4
	5 __acl__ = [
	6     (Allow, Everyone, 'view'),
	7     (Deny, Everyone, 'view'),
	8     ]

	The default authorization policy will allow everyone the view permission, even though later in the ACL you have an ACE that denies everyone the view permission.

	1 from pyramid.security import Everyone
	2 from pyramid.security import Allow
	3
	4 __acl__ = [
	5     (Allow, Everyone, 'view'),
	6     (Allow, 'group:editors', ('add', 'edit')),
	7     ]

	The acl can be collapsed as above.

# Special Principal Names

	pyramid.security.Everyone

	See the sample above.

	pyramid.security.Authenticated

	Any user with credentials as determined by the current security policy. You might think of it as any user that is “logged in”.

# Special Permissions

	pyramid.security.ALL_PERMISSIONS

	An object representing, literally, all permissions. Useful in an ACL like so: (Allow, 'fred', ALL_PERMISSIONS). Has the effect of indicating that a given principal “has” any permission asked for by the system.

# Special ACEs

	For example, an ACL which allows only fred the view permission for a particular resource despite what inherited ACLs may say when the default authorization policy is in effect might look like so:

	1 from pyramid.security import Allow
	2 from pyramid.security import DENY_ALL
	3
	4 __acl__ = [ (Allow, 'fred', 'view'), DENY_ALL ]

	“Under the hood”, the pyramid.security.DENY_ALL ACE equals the following:

	1 from pyramid.security import ALL_PERMISSIONS
	2 __acl__ = [ (Deny, Everyone, ALL_PERMISSIONS) ]

# ACL Inheritance and Location-Awareness

	While the default authorization policy is in place, if a resource object does not have an ACL when it is the context, its parent is consulted for an ACL. If that object does not have an ACL, its parent is consulted for an ACL, ad infinitum, until we’ve reached the root and there are no more parents left.

	In order to allow the security machinery to perform ACL inheritance, resource objects must provide location-awareness. Providing location-awareness means two things: the root object in the resource tree must have a _name__ attribute and a __parent__ attribute.

	1 class Blog(object):
	2     __name__ = ''
	3     __parent__ = None

	An object with a __parent__ attribute and a __name__ attribute is said to be location-aware. Location-aware objects define an __parent__ attribute which points at their parent object. The root object’s __parent__ is None.

# Changing the Forbidden View

	http://docs.pylonsproject.org/projects/pyramid/1.0/narr/hooks.html#changing-the-forbidden-view

# Debugging View Authorization Failures

	1 [app:main]
	2 use = egg:MyProject#app
	3 debug_authorization = true

	With this debug flag turned on, the response sent to the browser will also contain security debugging information in its body.

# Debugging Imperative Authorization Failures

	The pyramid.security.has_permission() API is used to check security within view functions imperatively. It returns instances of objects that are effectively booleans. But these objects are not raw True or False objects, and have information attached to them about why the permission was allowed or denied. The object will be one of pyramid.security.ACLAllowed, pyramid.security.ACLDenied, pyramid.security.Allowed, or pyramid.security.Denied, as documented in pyramid.security. At the very minimum these objects will have a msg attribute, which is a string indicating why the permission was denied or allowed. Introspecting this information in the debugger or via print statements when a call to has_permission() fails is often useful.
			
# Creating Your Own Authentication Policy
	Skipped.

# Creating Your Own Authorization Policy
	Skipped.


Combining Traversal and URL Dispatch
	Skipped.


Internationalization and Localization

# Creating a Translation String

	1) Using The TranslationString Class

	from pyramid.i18n import TranslationString
	ts = TranslationString('Add')

	The first argument to TranslationString is the msgid; it is required. It represents the key into the translation mappings provided by a particular localization.

	from pyramid.i18n import TranslationString
	ts = TranslationString('Add ${number}', mapping={'number':1})

	Within the string above, ${number} is a replacement marker. It will be replaced by whatever is in the mapping for a translation string.


	A translation string should also usually carry a domain. The domain represents a translation category to disambiguate it from other translations of the same msgid, in case they conflict.

	from pyramid.i18n import TranslationString
	ts = TranslationString('Add ${number}', mapping={'number':1}, domain='form')

	In this case, if it were trying to translate our msgid to German, it might try to find a translation from a gettext file within a translation directory like this one:

	locale/de/LC_MESSAGES/form.mo

	In other words, it would want to take translations from the form.mo translation file in the German language.

	from pyramid.i18n import TranslationString
	ts = TranslationString('add-number', default='Add ${number}', domain='form', mapping={'number':1})

	"default" argument here means, if there is corresponding string for msgid "add-number", it will use default value instead, and "default" may contain replacement either.

	2) Using the TranslationStringFactory Class

	from pyramid.i18n import TranslationStringFactory
	_ = TranslationStringFactory('pyramid')
	ts = _('Add ${number}', msgid='add-number', mapping={'number':1})

	Note

	We assigned the translation string factory to the name _. This is a convention which will be supported by translation file generation tools.

	"pyramid" is domain name while 'Add ${number}' is default value, As a result, the previous code example is completely equivalent (except for spelling) to:

	from pyramid.i18n import TranslationString as _
	ts = _('Add ${number}', msgid='add-number', mapping={'number':1}, domain='pyramid')

	Creating a unique domain for your application via a translation string factory is best practice. Using your own unique translation domain allows another person to reuse your application without needing to merge your translation files with his own. Instead, he can just include your package’s translation directory via the pyramid.config.Configurator.add_translation_dirs() method.

Note

For people familiar with Zope internationalization, a TranslationStringFactory is a lot like a zope.i18nmessageid.MessageFactory object. It is not a subclass, however.
Working With gettext Translation Files¶

The basis of Pyramid translation services is GNU gettext. Once your application source code files and templates are marked up with translation markers, you can work on translations by creating various kinds of gettext files.

Note

The steps a developer must take to work with gettext message catalog files within a Pyramid application are very similar to the steps a Pylons developer must take to do the same. See the Pylons internationalization documentation for more information.

GNU gettext uses three types of files in the translation framework, .pot files, .po files and .mo files.

.pot (Portable Object Template) files

    A .pot file is created by a program which searches through your project’s source code and which picks out every message identifier passed to one of the ‘_() functions (eg. translation string constructions). The list of all message identifiers is placed into a .pot file, which serves as a template for creating .po files.

.po (Portable Object) files

    The list of messages in a .pot file are translated by a human to a particular language; the result is saved as a .po file.

.mo (Machine Object) files

    A .po file is turned into a machine-readable binary file, which is the .mo file. Compiling the translations to machine code makes the localized program run faster.

The tool for working with gettext translation files related to a Pyramid application is Babel.
Installing Babel¶

In order for the commands related to working with gettext translation files to work properly, you will need to have Babel installed into the same environment in which Pyramid is installed.
Installation on UNIX¶

If the virtualenv into which you’ve installed your Pyramid application lives in /my/virtualenv, you can install Babel like so:

$ cd /my/virtualenv
$ bin/easy_install Babel

Installation on Windows¶

If the virtualenv into which you’ve installed your Pyramid application lives in C:\my\virtualenv, you can install Babel like so:

C> cd \my\virtualenv
C> bin\easy_install Babel

Changing the setup.py¶

You need to add a few boilerplate lines to your application’s setup.py file in order to properly generate gettext files from your application.

Note

See Creating a Pyramid Project to learn about about the composition of an application’s setup.py file.

In particular, add the Babel distribution to the install_requires list and insert a set of references to Babel message extractors within the call to setuptools.setup() inside your application’s setup.py file:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11

	

 setup(name="mypackage",
       # ...
       install_requires = [
             # ...
             'Babel',
             ],
       message_extractors = { '.': [
             ('**.py',   'chameleon_python', None ),
             ('**.pt',   'chameleon_xml', None ),
             ]},
       )

The message_extractors stanza placed into the setup.py file causes the Babel message catalog extraction machinery to also consider **.pt files when doing message id extraction.
Extracting Messages from Code and Templates¶

Once Babel is installed and your application’s setup.py file has the correct message extractor references, you may extract a message catalog template from the code and Chameleon templates which reside in your Pyramid application. You run a setup.py command to extract the messages:

$ cd /place/where/myapplication/setup.py/lives
$ mkdir -p myapplication/locale
$ python setup.py extract_messages

The message catalog .pot template will end up in:

myapplication/locale/myapplication.pot.
Translation Domains¶

The name myapplication above in the filename myapplication.pot denotes the translation domain of the translations that must be performed to localize your application. By default, the translation domain is the project name of your Pyramid application.

To change the translation domain of the extracted messages in your project, edit the setup.cfg file of your application, The default setup.cfg file of a Paster-generated Pyramid application has stanzas in it that look something like the following:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20

	

 [compile_catalog]
 directory = myproject/locale
 domain = MyProject
 statistics = true

 [extract_messages]
 add_comments = TRANSLATORS:
 output_file = myproject/locale/MyProject.pot
 width = 80

 [init_catalog]
 domain = MyProject
 input_file = myproject/locale/MyProject.pot
 output_dir = myproject/locale

 [update_catalog]
 domain = MyProject
 input_file = myproject/locale/MyProject.pot
 output_dir = myproject/locale
 previous = true

In the above example, the project name is MyProject. To indicate that you’d like the domain of your translations to be mydomain instead, change the setup.cfg file stanzas to look like so:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20

	

 [compile_catalog]
 directory = myproject/locale
 domain = mydomain
 statistics = true

 [extract_messages]
 add_comments = TRANSLATORS:
 output_file = myproject/locale/mydomain.pot
 width = 80

 [init_catalog]
 domain = mydomain
 input_file = myproject/locale/mydomain.pot
 output_dir = myproject/locale

 [update_catalog]
 domain = mydomain
 input_file = myproject/locale/mydomain.pot
 output_dir = myproject/locale
 previous = true

Initializing a Message Catalog File¶

Once you’ve extracted messages into a .pot file (see Extracting Messages from Code and Templates), to begin localizing the messages present in the .pot file, you need to generate at least one .po file. A .po file represents translations of a particular set of messages to a particular locale. Initialize a .po file for a specific locale from a pre-generated .pot template by using the setup.py init_catalog command:

$ cd /place/where/myapplication/setup.py/lives
$ python setup.py init_catalog -l es

By default, the message catalog .po file will end up in:

myapplication/locale/es/LC_MESSAGES/myapplication.po.

Once the file is there, it can be worked on by a human translator. One tool which may help with this is Poedit.

Note that Pyramid itself ignores the existence of all .po files. For a running application to have translations available, a .mo file must exist. See Compiling a Message Catalog File.
Updating a Catalog File¶

If more translation strings are added to your application, or translation strings change, you will need to update existing .po files based on changes to the .pot file, so that the new and changed messages can also be translated or re-translated.

First, regenerate the .pot file as per Extracting Messages from Code and Templates. Then use the setup.py update_catalog command.

$ cd /place/where/myapplication/setup.py/lives
$ python setup.py update_catalog

Compiling a Message Catalog File¶

Finally, to prepare an application for performing actual runtime translations, compile .po files to .mo files:

$ cd /place/where/myapplication/setup.py/lives
$ python setup.py compile_catalog

This will create a .mo file for each .po file in your application. As long as the translation directory in which the .mo file ends up in is configured into your application, these translations will be available to Pyramid.
Using a Localizer¶

A localizer is an object that allows you to perform translation or pluralization “by hand” in an application. You may use the pyramid.i18n.get_localizer() function to obtain a localizer. This function will return either the localizer object implied by the active locale negotiator or a default localizer object if no explicit locale negotiator is registered.

1
2
3
4

	

from pyramid.i18n import get_localizer

def aview(request):
    locale = get_localizer(request)

Performing a Translation¶

A localizer has a translate method which accepts either a translation string or a Unicode string and which returns a Unicode object representing the translation. So, generating a translation in a view component of an application might look like so:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10

	

from pyramid.i18n import get_localizer
from pyramid.i18n import TranslationString

ts = TranslationString('Add ${number}', mapping={'number':1},
                       domain='pyramid')

def aview(request):
    localizer = get_localizer(request)
    translated = localizer.translate(ts) # translation string
    # ... use translated ...

The get_localizer() function will return a pyramid.i18n.Localizer object bound to the locale name represented by the request. The translation returned from its pyramid.i18n.Localizer.translate() method will depend on the domain attribute of the provided translation string as well as the locale of the localizer.

Note

If you’re using Chameleon templates, you don’t need to pre-translate translation strings this way. See Chameleon Template Support for Translation Strings.
Performing a Pluralization¶

A localizer has a pluralize method with the following signature:

1
2

	

def pluralize(singular, plural, n, domain=None, mapping=None):
    ...

The singular and plural arguments should each be a Unicode value representing a message identifier. n should be an integer. domain should be a translation domain, and mapping should be a dictionary that is used for replacement value interpolation of the translated string. If n is plural for the current locale, pluralize will return a Unicode translation for the message id plural, otherwise it will return a Unicode translation for the message id singular.

The arguments provided as singular and/or plural may also be translation string objects, but the domain and mapping information attached to those objects is ignored.

1
2
3
4
5
6

	

from pyramid.i18n import get_localizer

def aview(request):
    localizer = get_localizer(request)
    translated = localizer.pluralize('Item', 'Items', 1, 'mydomain')
    # ... use translated ...

Obtaining the Locale Name for a Request¶

You can obtain the locale name related to a request by using the pyramid.i18n.get_locale_name() function.

1
2
3
4

	

from pyramid.i18n import get_locale_name

def aview(request):
    locale_name = get_locale_name(request)

This returns the locale name negotiated by the currently active locale negotiator or the default locale name if the locale negotiator returns None. You can change the default locale name by changing the default_locale_name setting; see Default Locale Name.

Once get_locale_name() is first run, the locale name is stored on the request object. Subsequent calls to get_locale_name() will return the stored locale name without invoking the locale negotiator. To avoid this caching, you can use the pyramid.i18n.negotiate_locale_name() function:

1
2
3
4

	

from pyramid.i18n import negotiate_locale_name

def aview(request):
    locale_name = negotiate_locale_name(request)

You can also obtain the locale name related to a request using the locale_name attribute of a localizer.

1
2
3
4
5

	

from pyramid.i18n import get_localizer

def aview(request):
    localizer = get_localizer(request)
    locale_name = localizer.locale_name

Obtaining the locale name as an attribute of a localizer is equivalent to obtaining a locale name by calling the get_locale_name() function.
Performing Date Formatting and Currency Formatting¶

Pyramid does not itself perform date and currency formatting for different locales. However, Babel can help you do this via the babel.core.Locale class. The Babel documentation for this class provides minimal information about how to perform date and currency related locale operations. See Installing Babel for information about how to install Babel.

The babel.core.Locale class requires a locale name as an argument to its constructor. You can use Pyramid APIs to obtain the locale name for a request to pass to the babel.core.Locale constructor; see Obtaining the Locale Name for a Request. For example:

1
2
3
4
5
6

	

from babel.core import Locale
from pyramid.i18n import get_locale_name

def aview(request):
    locale_name = get_locale_name(request)
    locale = Locale(locale_name)

Chameleon Template Support for Translation Strings¶

When a translation string is used as the subject of textual rendering by a Chameleon template renderer, it will automatically be translated to the requesting user’s language if a suitable translation exists. This is true of both the ZPT and text variants of the Chameleon template renderers.

For example, in a Chameleon ZPT template, the translation string represented by “some_translation_string” in each example below will go through translation before being rendered:

1

	

<span tal:content="some_translation_string"/>

1

	

<span tal:replace="some_translation_string"/>

1

	

<span>${some_translation_string}</span>

1

	

<a tal:attributes="href some_translation_string">Click here</a>

The features represented by attributes of the i18n namespace of Chameleon will also consult the Pyramid translations. See http://chameleon.repoze.org/docs/latest/i18n.html#the-i18n-namespace.

Note

Unlike when Chameleon is used outside of Pyramid, when it is used within Pyramid, it does not support use of the zope.i18n translation framework. Applications which use Pyramid should use the features documented in this chapter rather than zope.i18n.

Third party Pyramid template renderers might not provide this support out of the box and may need special code to do an equivalent. For those, you can always use the more manual translation facility described in Performing a Translation.
Mako Pyramid I18N Support¶

There exists a recipe within the Pyramid Cookbook named “Mako Internationalization” which explains how to add idiomatic I18N support to Mako templates.
Localization-Related Deployment Settings¶

A Pyramid application will have a default_locale_name setting. This value represents the default locale name used when the locale negotiator returns None. Pass it to the Configurator constructor at startup time:

1
2

	

from pyramid.config import Configurator
config = Configurator(settings={'default_locale_name':'de'})

You may alternately supply a default_locale_name via an application’s Paster .ini file:

1
2
3
4
5
6

	

[app:main]
use = egg:MyProject#app
reload_templates = true
debug_authorization = false
debug_notfound = false
default_locale_name = de

If this value is not supplied via the Configurator constructor or via a Paste config file, it will default to en.

If this setting is supplied within the Pyramid application .ini file, it will be available as a settings key:

1
2
3

	

from pyramid.threadlocal import get_current_registry
settings = get_current_registry().settings
default_locale_name = settings['default_locale_name']

“Detecting” Available Languages¶

Other systems provide an API that returns the set of “available languages” as indicated by the union of all languages in all translation directories on disk at the time of the call to the API.

It is by design that Pyramid doesn’t supply such an API. Instead, the application itself is responsible for knowing the “available languages”. The rationale is this: any particular application deployment must always know which languages it should be translatable to anyway, regardless of which translation files are on disk.

Here’s why: it’s not a given that because translations exist in a particular language within the registered set of translation directories that this particular deployment wants to allow translation to that language. For example, some translations may exist but they may be incomplete or incorrect. Or there may be translations to a language but not for all translation domains.

Any nontrivial application deployment will always need to be able to selectively choose to allow only some languages even if that set of languages is smaller than all those detected within registered translation directories. The easiest way to allow for this is to make the application entirely responsible for knowing which languages are allowed to be translated to instead of relying on the framework to divine this information from translation directory file info.

You can set up a system to allow a deployer to select available languages based on convention by using the pyramid.settings mechanism:

Allow a deployer to modify your application’s PasteDeploy .ini file:

1
2
3
4

	

[app:main]
use = egg:MyProject#app
# ...
available_languages = fr de en ru

Then as a part of the code of a custom locale negotiator:

1
2
3

	

from pyramid.threadlocal import get_current_registry
settings = get_current_registry().settings
languages = settings['available_languages'].split()

This is only a suggestion. You can create your own “available languages” configuration scheme as necessary.
Activating Translation¶

By default, a Pyramid application performs no translation. To turn translation on, you must:

    * add at least one translation directory to your application.
    * ensure that your application sets the locale name correctly.

Adding a Translation Directory¶

gettext is the underlying machinery behind the Pyramid translation machinery. A translation directory is a directory organized to be useful to gettext. A translation directory usually includes a listing of language directories, each of which itself includes an LC_MESSAGES directory. Each LC_MESSAGES directory should contain one or more .mo files. Each .mo file represents a message catalog, which is used to provide translations to your application.

Adding a translation directory registers all of its constituent message catalog files within your Pyramid application to be available to use for translation services. This includes all of the .mo files found within all LC_MESSAGES directories within each locale directory in the translation directory.

You can add a translation directory imperatively by using the pyramid.config.Configurator.add_translation_dirs() during application startup. For example:

1
2
3

	

from pyramid.config import Configurator
config.add_translation_dirs('my.application:locale/',
                            'another.application:locale/')

A message catalog in a translation directory added via add_translation_dirs() will be merged into translations from a message catalog added earlier if both translation directories contain translations for the same locale and translation domain.
Setting the Locale¶

When the default locale negotiator (see The Default Locale Negotiator) is in use, you can inform Pyramid of the current locale name by doing any of these things before any translations need to be performed:

    * Set the _LOCALE_ attribute of the request to a valid locale name (usually directly within view code). E.g. request._LOCALE_ = 'de'.
    * Ensure that a valid locale name value is in the request.params dictionary under the key named _LOCALE_. This is usually the result of passing a _LOCALE_ value in the query string or in the body of a form post associated with a request. For example, visiting http://my.application?_LOCALE_=de.
    * Ensure that a valid locale name value is in the request.cookies dictionary under the key named _LOCALE_. This is usually the result of setting a _LOCALE_ cookie in a prior response, e.g. response.set_cookie('_LOCALE_', 'de').

Note

If this locale negotiation scheme is inappropriate for a particular application, you can configure a custom locale negotiator function into that application as required. See Using a Custom Locale Negotiator.
Locale Negotiators¶

A locale negotiator informs the operation of a localizer by telling it what locale name is related to a particular request. A locale negotiator is a bit of code which accepts a request and which returns a locale name. It is consulted when pyramid.i18n.Localizer.translate() or pyramid.i18n.Localizer.pluralize() is invoked. It is also consulted when get_locale_name() or negotiate_locale_name() is invoked.
The Default Locale Negotiator¶

Most applications can make use of the default locale negotiator, which requires no additional coding or configuration.

The default locale negotiator implementation named default_locale_negotiator uses the following set of steps to dermine the locale name.

    * First, the negotiator looks for the _LOCALE_ attribute of the request object (possibly set directly by view code or by a listener for an event).
    * Then it looks for the request.params['_LOCALE_'] value.
    * Then it looks for the request.cookies['_LOCALE_'] value.
    * If no locale can be found via the request, it falls back to using the default locale name (see Localization-Related Deployment Settings).
    * Finally, if the default locale name is not explicitly set, it uses the locale name en.

Using a Custom Locale Negotiator¶

Locale negotiation is sometimes policy-laden and complex. If the (simple) default locale negotiation scheme described in Activating Translation is inappropriate for your application, you may create and a special locale negotiator. Subsequently you may override the default locale negotiator by adding your newly created locale negotiator to your application’s configuration.

A locale negotiator is simply a callable which accepts a request and returns a single locale name or None if no locale can be determined.

Here’s an implementation of a simple locale negotiator:

1
2
3

	

 def my_locale_negotiator(request):
     locale_name = request.params.get('my_locale')
     return locale_name

If a locale negotiator returns None, it signifies to Pyramid that the default application locale name should be used.

You may add your newly created locale negotiator to your application’s configuration by passing an object which can act as the negotiator (or a dotted Python name referring to the object) as the locale_negotiator argument of the Configurator instance during application startup. For example:

1
2

	

from pyramid.config import Configurator
config = Configurator(locale_negotiator=my_locale_negotiator)

Alternately, use the pyramid.config.Configurator.set_locale_negotiator() method.

For example:

1
2
3

	

from pyramid.config import Configurator
config = Configurator()
config.set_locale_negotiator(my_locale_negotiator)

















# For SQLAlchemy:
#     0. "service mysql status" to make sure mysql is running.
#     1. Make sure you log into mysql console and run "CREATE DATABASE studypylons DEFAULT CHARACTER SET utf8;" first, and if it's a mysql on amazon ec2, 3306 port on ec2 should be exposed for outsider.
#     2. vi development.ini to add mysql db url.
#     3. Put model classes like person.py, address.py into studypylons/model/
#     4. Run "paster setup-app development.ini" to create the tables in the database, this command will call studypylons/websetup.py
#     5. Run "paster serve --reload development.ini"
# Visiting http://127.0.0.1:5000/person/index to see a sample for SQLAlchemy
#
# Using the model standalone:
# % python
# Python 2.5.1 (r251:54863, Oct 5 2007, 13:36:32)
# [GCC 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)] on linux2
# Type "help", "copyright", "credits" or "license" for more information.
# >>> import sqlalchemy as sa
# >>> engine = sa.create_engine("sqlite:///test.sqlite")
# >>> from studypylons.model import init_model, Person
# >>> from studypylons.model.meta import Session, Base
# >>> init_model(engine)
# >>> a = Person()
# >>> a.name = "Aaa"
# >>> a.email = "aaa@example.com"
# >>> Session.add(a)
# >>> Session.commit()
#
# For Generating the Production Configuration
# paster make-config studypylons production.ini
#
# Put set-up once objects for the entire application to config/environment.py or lib/app_globals __init__() method.
#
# Put custom middleware to config/middleware.py at comment marker:
# # CUSTOM MIDDLEWARE HERE (filtered by error hanlding middlewares)
#
# StudyPylons is a standard Python package which contains setup.py where defines the package dependencies
# To re-parse the setup.py line for new dependencies, run "$ python setup.py develop"
#
