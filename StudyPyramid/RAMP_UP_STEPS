This document is mainly from official site of pyramid: http://docs.pylonsproject.org/projects/pyramid/1.0/index.html, check it out if you can find answer below.

First Pyramid Application:
1. start it:
	~/devenv/bin/python helloworld.py
	OR
	source ~/devenv/bin/activate && python helloworld.py
2. visit it:
	http://localhost:8080/
	http://localhost:8080/goodbye
	http://localhost:8080/hello

Creating a Pyramid Project:
# Before you do anything else, activate virtual python env first:
	source ~/devenv/bin/activate
# Create new project
	paster create -t pyramid_routesalchemy MyProject
# Make sure from now on your working directory is your project folder: MyProject
	cd MyProject
# Install new project for development, this will install a distribution into the python interpreter's library.
	python setup.py develop
# Run test case, the tests are in MyProject/myproject/tests.py
	python setup.py test -q
# Interactive shell, "MyProject" here is the value of section name "app" in development.ini file, see more about pshell in pyramid docs.
	paster pshell development.ini MyProject
# Running the project application
	paster serve development.ini
	OR for development phase:
	paster serve development.ini --reload
	OR for production phase:
	paster serve production.ini
# tar your application:
	python setup.py sdist
	This will tar a .tar.gz file for your application, and make sure all the non-python file types are in your MANIFEST.in file, otherwise, the tar will miss these unspecified file types.
# Modifying Package Structure:
	You can create a new package for example "blog" under "myproject" folder and "cp views.py blog/views.py", and change the "myproject/__init__.py"
	from:
	config.add_view('myproject.views.my_view', renderer='myproject:templates/mytemplate.pt')
	to:
	config.add_view('myproject.views.blog.my_view', renderer='myproject:templates/mytemplate.pt')
# myproject/__init__.py:main function:
	def main(global_config, **settings=settings):
		config = Configurator(root_factory = Root, settings = settings)
		// blablabla
	if you have a "[DEFAULT]" section in development.ini, "global_config" here stores all the key/values pairs in "[DEFAULT]" section.
	"settings" here stores all the key/values pairs in "[app.MyProject]" section in development except one: "use = egg:MyProject"
	 you can put anything you want here into "settings" and access it later from "view callable" by invoking request.registry.setting dictionary at application runtime.

URL dispatch:
	1. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	from myproject.views import myview
	config.add_route('myroute', '/prefix/{one}/{two}', view=myview)
	2. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	config.add_route('myroute', '/prefix/{one}/{two}', view='myproject.views.myview')
# Route pattern syntax:

	pattern: {foo}/bar/baz equals to /{foo}/bar/baz, the slash wil be prepended automatically anyway.

	pattern: foo/{baz}/{bar}
	url: foo/1/2        -> {'baz':u'1', 'bar':u'2'}
	url: foo/abc/def    -> {'baz':u'abc', 'bar':u'def'}
	url: foo/1/2/        -> No match (trailing slash)
	url: bar/abc/def     -> First segment literal mismatch
	And the the matched dict will be availabe as "request.matchdic"

	pattern: foo/{name}.html
	url: /foo/biz.html  -> {'name':u'biz'}

	pattern: foo/{name}.{ext}
	url: /foo/biz.html  -> {'name':u'biz', 'ext':u'html'}

	regular expession pattern: {foo} is actually: {foo:[^/]+} by default so that a replacement markder don't need to be preceded by a / slash, you can also change it to {foo:\d+}

	regular expression pattern: foo/{bar}
	foo/La%20Pe%C3%B1a  -> {'bar':u'La Pe\xf1a'}
	The matchdict will be URL-decoded / UTF-8 decoded.

	If the pattern has a * in it, the name which follows it is considered a “remainder match”. A remainder match must come at the end of the pattern.
	Unlike segment replacement markers, it does not need to be preceded by a slash. For example:
	regular expression pattern: foo/{baz}/{bar}*fizzle
	foo/1/2/           ->	{'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  ->	{'baz':u'abc', 'bar':u'def', 'fizzle':(u'a', u'b', u'c')}

	regular expression way to the similar things for above:
	foo/{baz}/{bar}{fizzle:.*}
	foo/1/2/           -> {'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  -> {'baz':u'abc', 'bar':u'def', 'fizzle': u'a/b/c')}
	This occurs because the default regular expression for a marker is [^/]+ which will match everything up to the first /, while {fizzle:.*} will result in a regular expression match of .* capturing the
remainder into a single value.

# Route Declaration Ordering:
	memebers/{def}
	memebers/abc
	The "memebers/abc" will never be matched, since the ordering will always match the members/{def} first.

# Custom Route Predicates

	info['match'] is useful when predicates need access to the route match. For example:

	def any_of(segment_name, *allowed):
	    def predicate(info, request):
	        if info['match'][segment_name] in allowed:
	            return True
	    return predicate
	num_one_two_or_three = any_of('num', 'one', 'two', 'three')
	config.add_route('num', '/{num}', custom_predicates=(num_one_two_or_three,))
	
	This will ensure the "num" segment here is one of the values one, two or three.

	info['route'] is an object has two useful attributes: name and pattern
	1  def twenty_ten(info, request):
	2      if info['route'].name in ('ymd', 'ym', 'y'):
	3          return info['match']['year'] == '2010'
	4
	5  config.add_route('y', '/{year}', custom_predicates=(twenty_ten,))
	6  config.add_route('ym', '/{year}/{month}', custom_predicates=(twenty_ten,))
	7  config.add_route('ymd', '/{year}/{month}/{day}',
	8                   custom_predicates=(twenty_ten,))
	The above predicate, when added to a number of route configurations ensures that the year match argument is ‘2010’ if and only if the route name is ‘ymd’, ‘ym’, or ‘y’.

# The Matched Route
	The matched route is availabe as "request.matched_route", the useful attribute of this object is the "name" attribute, if no route url pattern matches, request.matched_route is None.

# Route Examples:
	Example 3:
	An example of using a route with a factory:
	config.add_route('idea', 'ideas/{idea}', view='myproject.views.idea_view', factory='myproject.resources.Idea')
	The above route will manufacture an Idea resource as a context, assuming that mypackage.resources.Idea resolves to a class that accepts a request in its __init__. For example:
	class Idea(object):
		def __init__(self, request):
			pass
	In a more complicated application, this root factory might be a class representing a SQLAlchemy model.
	
	Example 4:
	config.add_route('idea', 'site/{id}')
	config.add_view(route_name='idea', view='mypackage.views.site_view')
	are same to
	config.add_route('idea', 'site/{id}', view='mypackage.views.site_view')

# Matching the Root URL
	config.add_route('root', '', view='mypackage.views.root_view')
	Or provide the literal string / as the pattern:
	config.add_route('root', '/', view='mypackage.views.root_view')

# Generating Route URLs

	If you’ve configured a route with the name “foo” and the pattern “{a}/{b}/{c}”, you might do this.

	1 from pyramid.url import route_url
	2 url = route_url('foo', request, a='1', b='2', c='3')

	This would return something like the string http://example.com/1/2/3 (at least if the current protocol and hostname implied http:/example.com).

# Redirecting to Slash-Appended Routes
	config.add_route('hasslash', 'has_slash/', view='myproject.views.has_slash')
	config.add_view(context='pyramid.exceptions.NotFound', view='pyramid.view.append_slash_notfound_view')

	This will make sure the url path like "/has_slash" to be redirect to "/has_slash/"

	If still, when it can't redirect to a slash-appended url, it will go to 404 not found page. In this case, if you want to custom not found view when it can't redirect to a slash-appended url, do this:

	from pyramid.exceptions import NotFound
	from pyramid.view import AppendSlashNotFoundViewFactory

	def notfound_view(context, request):
		return HTTPNotFound('It aint there, stop trying!')

	custom_append_slash = AppendSlashNotFoundViewFactory(notfound_view)
	config.add_view(custom_append_slash, context=NotFound)

# Cleaning Up After a Request:
	
	In mypackage.__init__ module:

	from mypackage.models import DBSession

	from pyramid.events import subscriber
	from pyramid.events import NewRequest

	def cleanup_callback(request):
		DBSession.remove()

	@subscriber(NewRequest)
	def add_cleanup_callback(event):
		event.request.add_finished_callback(cleanup_callback)

	And make sure pyramid.config.Configurator.scan() is called since we have @subscriber here.

# Using Pyramid Security With URL Dispatch
	allow the editor the view permission:
	class Article(object):
		def __init__(self, request):
		   matchdict = request.matchdict
		   article = matchdict.get('article', None)
		   if article == '1':
			   self.__acl__ = [ (Allow, 'editor', 'view') ]

# Debugging Route Matching
	jiawzhang@home-pc:~$ PYRAMID_DEBUG_ROUTEMATCH=true paster server development.ini

# Displaying All Application Routes
	jiawzhang@home-pc:~$ paster proutes development.ini MyProject


Much Ado About Traversal

	It introduce the concepts on "Traversal", "Resource", "View Lookup" and "Use Cases" for Traversal, read it will be helpful for knowing general concept purpose.
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/muchadoabouttraversal.html


Traversal

    Skipped.
	Check it out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/traversal.html


Views


# Defining a View Callable as a Function

	1 from pyramid.response import Response
	2
	3 def hello_world(request):
	4     return Response('Hello world!')

# Defining a View Callable as a Class

	Views defined as classes must have the following traits:
	• an __init__ method that accepts a request argument.
	• a __call__ (or other) method that accepts no parameters and which returns a response.

	1 from pyramid.response import Response
	2
	3 class MyView(object):
	4     def __init__(self, request):
	5         self.request = request
	6
	7     def __call__(self):
	8         return Response('hello')

	If you want to access "context", try "request.context"

# View Callable Responses

	1 from pyramid.response import Response
	2
	3 def view(request):
	4     return Response('OK')

	You don’t need to always use Response to represent a response like HTTPFound in pyramid.httpexceptions can be returned too. A view can actually return any object that has the following attributes.

	status: The HTTP status code (including the name) for the response as a string. E.g. 200 OK or 401 Unauthorized.
	headerlist: A sequence of tuples representing the list of headers that should be set in the response. E.g. [('Content-Type', 'text/html'), ('Content-Length', '412')]
	app_iter: An iterable representing the body of the response. This can be a list, e.g. ['<html><head></head><body>Hello world!</body></html>'] or it can be a file-like object, or any other sort of iterable.

# Using a View Callable to Do an HTTP Redirect

	You can issue an HTTP redirect from within a view by returning a particular kind of response.

	1 from pyramid.httpexceptions import HTTPFound
	2
	3 def myview(request):
	4     return HTTPFound(location='http://example.com')

	All exception types from the pyramid.httpexceptions module implement the Response interface; any can be returned as the response from a view.
	It also includes other response types that imply other HTTP response codes, such as HTTPUnauthorized for 401 Unauthorized.
					
# Using Special Exceptions In View Callables

	Usually when a Python exception is raised within a view callable, Except pyramid.exceptions.NotFound and pyramid.exceptions.Forbidden,
	Pyramid allows all the other exception to propagate all the way out to the WSGI server which invoked the application.
	The two special exceptions accept a single positional constructor argument: a message.
	If NotFound is raised within view code, the result of the Not Found View will be returned to the user agent which performed the request.
	If Forbidden is raised within view code, the result of the Forbidden View will be returned to the user agent which performed the request.
	In all cases, the message provided to the exception constructor is made available to the view which Pyramid invokes as request.exception.args[0].

# Exception Views

	For example, given the following exception class in a module named helloworld.exceptions:

	1 class ValidationFailure(Exception):
	2     def __init__(self, msg):
	3         self.msg = msg

	You can wire a view callable to be called whenever any of your other code raises a hellworld.exceptions.ValidationFailure exception:

	1 from helloworld.exceptions import ValidationFailure
	2
	3 @view_config(context=ValidationFailure)
	4 def failed_validation(exc, request):
	5     response =  Response('Failed validation: %s' % exc.msg)
	6     response.status_int = 500
	7     return response

	This view callable will be invoked whenever a helloworld.exceptions.ValidationError is raised by your application’s view code.

	Other normal view predicates can also be used in combination with an exception view registration:

	1 from pyramid.view import view_config
	2 from pyramid.exceptions import NotFound
	3 from pyramid.httpexceptions import HTTPNotFound
	4
	5 @view_config(context=NotFound, route_name='home')
	6 def notfound_view(request):
	7     return HTTPNotFound()

	The above exception view names the route_name of home, meaning that it will only be called when the route matched has a name of home.

# Handling Form Submissions in View Callables (Unicode and Character Set Issues)

	As an example, let’s assume that the following form page is served up to a browser client, and its action points at some Pyramid view code:

	1 <html xmlns="http://www.w3.org/1999/xhtml">
	2   <head>
	3     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	4   </head>
	5   <form method="POST" action="myview">
	6     <div>
	7       <input type="text" name="firstname"/>
	8     </div>
	9     <div>
	10       <input type="text" name="lastname"/>
	11     </div>
	12     <input type="submit" value="Submit"/>
	13   </form>
	14 </html>

	The values below in the request is converted from UTF-8 to Unicode implicitily.

	1 def myview(request):
	2     firstname = request.params['firstname']
	3     lastname = request.params['lastname']

	So make sure "charset=UTF-8" is always set in HTML head meta tag, otherwise this implicitily convertion will be failed.
	Since this implicitily convertion from UTF-8 to Unicode happens already, don't do this once again like: reqeust.params['firstname'].decode('utf-8')
	This convertion will happen only in reqeust.params, request.GET, request.POST
				 
Renderers

	A view needn’t always return a Response object. If a view happens to return something which does not implement the Pyramid Response interface,
	Pyramid will attempt to use a renderer to construct a response. For example:

	from pyramid.response import Response
	from pyramid.view import view_config

	@view_config(renderer='json')
	def hello_world(request):
		return {'content':'Hello!'}
	
	Means, you should either return a "Reponse" or specify a "renderer" to construct a respose.

# Writing View Callables Which Use a Renderer

	1 config.add_view('myproject.views.my_view', renderer='json')

	Returning "response" will overwrite specifying renderer.
	For example, if your view callable returns an instance of the pyramid.httpexceptions.HTTPFound class as a response, no renderer will be employed.

	1 from pyramid.httpexceptions import HTTPFound
	2
	3 def view(request):
	4     return HTTPFound(location='http://example.com') # any renderer avoided, a http redirect instead.

# Built-In Renderers
	1. string:String Render

	@view_config(renderer='string')
	def hello_world(request):
		return {'content':'Hello!'}

	2. json:JSON Render

	@view_config(renderer='json')
	def hello_world(request):
		return {'content':'Hello!'}
	
	OR

	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='json')
	
	@view_config and config.add_view() are actually same thing.

	
	3. *.pt or *.txt: Chameleon Template Renders

	1) relative path is different from Mako, which means relative to the path which defines the view callable. 
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='templates/foo.pt')

	2) asset specification, same to Mako.
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='myproject:templates/foo.pt')
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='myproject:templates/foo.txt')

	4. *.mak or *.mako: Mako Template Render

	1) relative path(The relative 'foo.mako' below is not relative to the package, but is relative to the directory configured for Mako via the mako.directories configuration file setting.):
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='foo.mako')

	2) asset specification(e.g. apackage:templates/sometemplate.mak):
	config.add_view('myproject.views.hello_world', name='hello', context='myproject.resources.Hello', renderer='mypackage:templates/foo.mak')

# Varying Attributes of Rendered Responses

	View callables that don’t directly return a response should set these attributes on the request object via setattr during their execution, to influence associated response attributes.
	If return a response directly, you can set attributes on Response object I think, see later.

	response_content_type: Defines the content-type of the resulting response, e.g. text/xml.
	response_headerlist: A sequence of tuples describing cookie values that should be set in the response, e.g. [('Set-Cookie', 'abc=123'), ('X-My-Header', 'foo')].
	response_status: A WSGI-style status code (e.g. 200 OK) describing the status of the response.
	response_charset: The character set (e.g. UTF-8) of the response.
	response_cache_for: A value in seconds which will influence Cache-Control and Expires headers in the returned response. The same can also be achieved by returning various values in the response_headerlist, this is purely a convenience. 

	For example:

	from pyramid.view import view_config

	@view_config(name='gone', renderer='templates/gone.pt')
	def myview(request):
		request.response_status = '404 Not Found'
		return {'URL':request.URL}

# Adding and Changing Renderers
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/renderers.html

# Overriding A Renderer At Runtime
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/renderers.html

Templates

# Using Templates Directly

	In this section, it's actually return Response rather than specifying renderer.

	1 from pyramid.renderers import render_to_response
	2
	3 def sample_view(request):
	4     return render_to_response('mypackage:templates/foo.mako',
	5                               {'foo':1, 'bar':2},
	6                               request=request)

	render_to_response() here is an extension api for the native template api offered by a giving template engine like Chameleon or Mako.

	Or, you can generate string first, then construct the response like below, it's same to above.

	1 from pyramid.renderers import render
	2 from pyramid.response import Response
	3
	4 def sample_view(request):
	5     result = render('mypackage:templates/foo.pt',
	6                     {'foo':1, 'bar':2},
	7                     request=request)
	8     response = Response(result)
	9     return response

	It's also doable to invoke your own 3rd party template Apis in view callable, since you can construct Response like above.
	See more: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/templates.html

	If you want to control more about response, do something like below:
	7     response.content_type = 'text/plain'
	8     response.status_int = 204

# System Values Used During Rendering
	context
	    The current Pyramid context if request was provided as a keyword argument, or None.
	request
		The request provided as a keyword argument.
	renderer_name
		The renderer name used to perform the rendering, e.g. mypackage:templates/foo.pt.
	renderer_info
		An object implementing the pyramid.interfaces.IRendererInfo interface. Basically, an object with the following attributes: name, package and type.
	These variables are made as top-level template variables, you can access them in template by something like ${request}, ${render_info.name}

# Templates Used as Renderers via Configuration

	1 from pyramid.view import view_config
	2
	3 @view_config(renderer='templates/foo.pt')
	4 def my_view(request):
	5     return {'foo':1, 'bar':2}

	This is a better way compared with "# Using Template Directly"
	if you want to do the same thing in "# Using Template Directly" to control more about response, you should set request rather than response, see: "# Varying Attributes of Rendered Responses"

# Templating With Mako Templates

	from pyramid.view import view_config

	@view_config(renderer='foo.mak')
	def my_view(request):
		return {'project':'my project'}

	For the above view callable to work, the following setting needs to be present in the application stanza of your configuration’s ini file:
	mako.directories = mypackage:templates
	And make sure you will have "foo.mak" in your "mypackage:templates" folder, "foo.mak" here is relative to "mypackage:templates" we defined.

# A Sample Mako Template
	 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
	 <html xmlns="http://www.w3.org/1999/xhtml" xmlns:tal="http://xml.zope.org/namespaces/tal">
	 <head>
		 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
		 <title>${project} Application</title>
	 </head>
	   <body>
		  <h1 class="title">Welcome to <code>${project}</code>, an
		   application generated by the <a href="http://docs.pylonsproject.org/projects/pyramid/dev/">pyramid</a> web application framework.</h1>
	   </body>
	 </html>

# Automatically Reloading Templates
	[app:main]
	use = egg:MyProject#app
	reload_templates = true


View Configuration

# View configuration parameters:
	1) non predicate arguments 2) predicate arguments
	Check out: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/viewconfig.html

# View Configuration Using the @view_config Decorator
	It's a better way compared with imperative configuration for the same purpose.

	An example of the view_config decorator might reside in a Pyramid application module views.py:

	1 from resources import MyResource
	2 from pyramid.view import view_config
	3 from pyramid.response import Response
	4
	5 @view_config(name='my_view', request_method='POST', context=MyResource,
	6              permission='read')
	7 def my_view(request):
	8     return Response('OK')

	Using this decorator as above replaces the need to add this imperative configuration stanza:

	1 config.add_view('.views.my_view', name='my_view', request_method='POST',
	2                 context=MyResource, permission='read')

	All arguments to view_config may be omitted. For example:

	1 from pyramid.response import Response
	2 from pyramid.view import view_config
	3
	4 @view_config()
	5 def my_view(request):
	6     """ My view """
	7     return Response()

	To make Pyramid process your view_config declarations, you must do use the scan method of a Configurator:

	1 # config is assumed to be an instance of the
	2 # pyramid.config.Configurator class
	3 config.scan()

@view_config Placement

	A view_config decorator can be placed in various points in your application.

	If your view callable is a function, it may be used as a function decorator:

	1 from pyramid.view import view_config
	2 from pyramid.response import Response
	3
	4 @view_config(name='edit')
	5 def edit(request):
	6     return Response('edited!')

	If your view callable is a class, the decorator can also be used as a class decorator in Python 2.6 and better (Python 2.5 and below do not support class decorators).

	1 from pyramid.response import Response
	2 from pyramid.view import view_config
    3
	4 @view_config()
	5 class MyView(object):
    6     def __init__(self, request):
    7         self.request = request
	8
	9     def __call__(self):
	10         return Response('hello')

	More than one view_config decorator can be stacked on top of any number of others. Each decorator creates a separate view registration. For example:

	from pyramid.view import view_config
	from pyramid.response import Response

	@view_config(name='edit')
	@view_config(name='change')
	def edit(request):
		    return Response('edited!')

	This registers the same view under two different names.

	The decorator can also be used against class methods:

	 from pyramid.response import Response
	 from pyramid.view import view_config

	 class MyView(object):
		 def __init__(self, request):
			 self.request = request

		 @view_config(name='hello')
		 def amethod(self):
			 return Response('hello')

	The code above is equivalent/same to below, means by default it will invoke __call__ method in class, but add a non-predicate paramter "attr" can specify a method you want to be called,
	when the view callable is invoked.

	from pyramid.response import Response
	from pyramid.view import view_config

	@view_config(attr='amethod', name='hello')
	class MyView(object):
	    def __init__(self, request):
            self.request = request

	    def amethod(self):
	        return Response('hello')

# View Registration Using add_view()

	1 from pyramid.response import Response
	2
	3 def hello_world(request):
	4     return Response('hello!')
	5
	6 # config is assumed to be an instance of the
	7 # pyramid.config.Configurator class
	8 config.add_view(hello_world, name='hello.html')


# Using Resource Interfaces in View Configuration
	I've skipped this portion, since it's traverse/resource/zope related.
	Check it out later: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/viewconfig.html

# Configuring View Security

	1 # config is an instance of pyramid.config.Configurator
	2
	3 config.add_view('myproject.views.add_entry', name='add.html',
	4                 context='myproject.resources.IBlog', permission='add')

	When an authorization policy is enabled, this view will be protected with the add permission.
	The view will not be called if the user does not possess the add permission relative to the current context.
	Instead the forbidden view result will be returned to the client as per Protecting Views with Permissions.
	Question: In Router based pyramid, the context here is always "root" ?

# NotFound Errors:

	Set debug_notfound = True in configuration .ini file will tell you why a view was not found from stderr, and browser representation of the error will include the same information.


Resources
	Skipped.
	Check it out if necessary at http://docs.pylonsproject.org/projects/pyramid/1.0/narr/resources.html#resources-which-implement-interfaces
































# For SQLAlchemy:
#     0. "service mysql status" to make sure mysql is running.
#     1. Make sure you log into mysql console and run "CREATE DATABASE studypylons DEFAULT CHARACTER SET utf8;" first, and if it's a mysql on amazon ec2, 3306 port on ec2 should be exposed for outsider.
#     2. vi development.ini to add mysql db url.
#     3. Put model classes like person.py, address.py into studypylons/model/
#     4. Run "paster setup-app development.ini" to create the tables in the database, this command will call studypylons/websetup.py
#     5. Run "paster serve --reload development.ini"
# Visiting http://127.0.0.1:5000/person/index to see a sample for SQLAlchemy
#
# Using the model standalone:
# % python
# Python 2.5.1 (r251:54863, Oct 5 2007, 13:36:32)
# [GCC 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)] on linux2
# Type "help", "copyright", "credits" or "license" for more information.
# >>> import sqlalchemy as sa
# >>> engine = sa.create_engine("sqlite:///test.sqlite")
# >>> from studypylons.model import init_model, Person
# >>> from studypylons.model.meta import Session, Base
# >>> init_model(engine)
# >>> a = Person()
# >>> a.name = "Aaa"
# >>> a.email = "aaa@example.com"
# >>> Session.add(a)
# >>> Session.commit()
#
# For Generating the Production Configuration
# paster make-config studypylons production.ini
#
# Put set-up once objects for the entire application to config/environment.py or lib/app_globals __init__() method.
#
# Put custom middleware to config/middleware.py at comment marker:
# # CUSTOM MIDDLEWARE HERE (filtered by error hanlding middlewares)
#
# StudyPylons is a standard Python package which contains setup.py where defines the package dependencies
# To re-parse the setup.py line for new dependencies, run "$ python setup.py develop"
#
