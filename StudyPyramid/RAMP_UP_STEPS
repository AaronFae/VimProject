This document is mainly from official site of pyramid: http://docs.pylonsproject.org/projects/pyramid/1.0/index.html, check it out if you can find answer below.

First Pyramid Application:
1. start it:
	~/devenv/bin/python helloworld.py
	OR
	source ~/devenv/bin/activate && python helloworld.py
2. visit it:
	http://localhost:8080/
	http://localhost:8080/goodbye
	http://localhost:8080/hello

Creating a Pyramid Project:
	source ~/devenv/bin/activate
# Create new project
	paster create -t pyramid_routesalchemy MyProject
# Make sure from now on your working directory is your project folder: MyProject
	cd MyProject
# Install new project for development, this will install a distribution into the python interpreter's library.
	python setup.py develop
# Run test case, the tests are in MyProject/myproject/tests.py
	python setup.py test -q
# Interactive shell, "MyProject" here is the value of section name "app" in development.ini file, see more about pshell in pyramid docs.
	paster pshell development.ini MyProject
# Running the project application
	paster serve development.ini
	OR for development phase:
	paster serve development.ini --reload
	OR for production phase:
	paster serve production.ini
# tar your application:
	python setup.py sdist
	This will tar a .tar.gz file for your application, and make sure all the non-python file types are in your MANIFEST.in file, otherwise, the tar will miss these unspecified file types.
# Modifying Package Structure:
	You can create a new package for example "blog" under "myproject" folder and "cp views.py blog/views.py", and change the "myproject/__init__.py"
	from:
	config.add_view('myproject.views.my_view', renderer='myproject:templates/mytemplate.pt')
	to:
	config.add_view('myproject.views.blog.my_view', renderer='myproject:templates/mytemplate.pt')
# myproject/__init__.py:main function:
	def main(global_config, **settings=settings):
		config = Configurator(root_factory = Root, settings = settings)
		// blablabla
	if you have a "[DEFAULT]" section in development.ini, "global_config" here stores all the key/values pairs in "[DEFAULT]" section.
	"settings" here stores all the key/values pairs in "[app.MyProject]" section in development except one: "use = egg:MyProject"
	 you can put anything you want here into "settings" and access it later from "view callable" by invoking request.registry.setting dictionary at application runtime.

URL dispatch:
	1. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	from myproject.views import myview
	config.add_route('myroute', '/prefix/{one}/{two}', view=myview)
	2. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	config.add_route('myroute', '/prefix/{one}/{two}', view='myproject.views.myview')
# Route pattern syntax:

	pattern: {foo}/bar/baz equals to /{foo}/bar/baz, the slash wil be prepended automatically anyway.

	pattern: foo/{baz}/{bar}
	url: foo/1/2        -> {'baz':u'1', 'bar':u'2'}
	url: foo/abc/def    -> {'baz':u'abc', 'bar':u'def'}
	url: foo/1/2/        -> No match (trailing slash)
	url: bar/abc/def     -> First segment literal mismatch
	And the the matched dict will be availabe as "request.matchdic"

	pattern: foo/{name}.html
	url: /foo/biz.html  -> {'name':u'biz'}

	pattern: foo/{name}.{ext}
	url: /foo/biz.html  -> {'name':u'biz', 'ext':u'html'}

	regular expession pattern: {foo} is actually: {foo:[^/]+} by default so that a replacement markder don't need to be preceded by a / slash, you can also change it to {foo:\d+}

	regular expression pattern: foo/{bar}
	foo/La%20Pe%C3%B1a  -> {'bar':u'La Pe\xf1a'}
	The matchdict will be URL-decoded / UTF-8 decoded.

	If the pattern has a * in it, the name which follows it is considered a “remainder match”. A remainder match must come at the end of the pattern.
	Unlike segment replacement markers, it does not need to be preceded by a slash. For example:
	regular expression pattern: foo/{baz}/{bar}*fizzle
	foo/1/2/           ->	{'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  ->	{'baz':u'abc', 'bar':u'def', 'fizzle':(u'a', u'b', u'c')}

	regular expression way to the similar things for above:
	foo/{baz}/{bar}{fizzle:.*}
	foo/1/2/           -> {'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  -> {'baz':u'abc', 'bar':u'def', 'fizzle': u'a/b/c')}
	This occurs because the default regular expression for a marker is [^/]+ which will match everything up to the first /, while {fizzle:.*} will result in a regular expression match of .* capturing the
remainder into a single value.

# Route Declaration Ordering:
	memebers/{def}
	memebers/abc
	The "memebers/abc" will never be matched, since the ordering will always match the members/{def} first.

# Custom Route Predicates

	info['match'] is useful when predicates need access to the route match. For example:

	def any_of(segment_name, *allowed):
	    def predicate(info, request):
	        if info['match'][segment_name] in allowed:
	            return True
	    return predicate
	num_one_two_or_three = any_of('num', 'one', 'two', 'three')
	config.add_route('num', '/{num}', custom_predicates=(num_one_two_or_three,))
	
	This will ensure the "num" segment here is one of the values one, two or three.

	info['route'] is an object has two useful attributes: name and pattern
	1  def twenty_ten(info, request):
	2      if info['route'].name in ('ymd', 'ym', 'y'):
	3          return info['match']['year'] == '2010'
	4
	5  config.add_route('y', '/{year}', custom_predicates=(twenty_ten,))
	6  config.add_route('ym', '/{year}/{month}', custom_predicates=(twenty_ten,))
	7  config.add_route('ymd', '/{year}/{month}/{day}',
	8                   custom_predicates=(twenty_ten,))
	The above predicate, when added to a number of route configurations ensures that the year match argument is ‘2010’ if and only if the route name is ‘ymd’, ‘ym’, or ‘y’.

# The Matched Route
	The matched route is availabe as "request.matched_route", the useful attribute of this object is the "name" attribute, if no route url pattern matches, request.matched_route is None.

# Route Examples:
	Example 3:
	An example of using a route with a factory:
	config.add_route('idea', 'ideas/{idea}', view='myproject.views.idea_view', factory='myproject.resources.Idea')
	The above route will manufacture an Idea resource as a context, assuming that mypackage.resources.Idea resolves to a class that accepts a request in its __init__. For example:
	class Idea(object):
		def __init__(self, request):
			pass
	In a more complicated application, this root factory might be a class representing a SQLAlchemy model.
	
	Example 4:
	config.add_route('idea', 'site/{id}')
	config.add_view(route_name='idea', view='mypackage.views.site_view')
	are same to
	config.add_route('idea', 'site/{id}', view='mypackage.views.site_view')

# Matching the Root URL
	config.add_route('root', '', view='mypackage.views.root_view')
	Or provide the literal string / as the pattern:
	config.add_route('root', '/', view='mypackage.views.root_view')

# Generating Route URLs

	If you’ve configured a route with the name “foo” and the pattern “{a}/{b}/{c}”, you might do this.

	1 from pyramid.url import route_url
	2 url = route_url('foo', request, a='1', b='2', c='3')

	This would return something like the string http://example.com/1/2/3 (at least if the current protocol and hostname implied http:/example.com).

# Redirecting to Slash-Appended Routes
	config.add_route('hasslash', 'has_slash/', view='myproject.views.has_slash')
	config.add_view(context='pyramid.exceptions.NotFound', view='pyramid.view.append_slash_notfound_view')

	This will make sure the url path like "/has_slash" to be redirect to "/has_slash/"

	If still, when it can't redirect to a slash-appended url, it will go to 404 not found page. In this case, if you want to custom not found view when it can't redirect to a slash-appended url, do this:

	from pyramid.exceptions import NotFound
	from pyramid.view import AppendSlashNotFoundViewFactory

	def notfound_view(context, request):
		return HTTPNotFound('It aint there, stop trying!')

	custom_append_slash = AppendSlashNotFoundViewFactory(notfound_view)
	config.add_view(custom_append_slash, context=NotFound)

# Cleaning Up After a Request:
	
	In mypackage.__init__ module:

	from mypackage.models import DBSession

	from pyramid.events import subscriber
	from pyramid.events import NewRequest

	def cleanup_callback(request):
		DBSession.remove()

	@subscriber(NewRequest)
	def add_cleanup_callback(event):
		event.request.add_finished_callback(cleanup_callback)

	And make sure pyramid.config.Configurator.scan() is called since we have @subscriber here.

# Using Pyramid Security With URL Dispatch
	allow the editor the view permission:
	class Article(object):
		def __init__(self, request):
		   matchdict = request.matchdict
		   article = matchdict.get('article', None)
		   if article == '1':
			   self.__acl__ = [ (Allow, 'editor', 'view') ]

# Debugging Route Matching
	jiawzhang@home-pc:~$ PYRAMID_DEBUG_ROUTEMATCH=true paster server development.ini

# Displaying All Application Routes
	jiawzhang@home-pc:~$ paster proutes development.ini MyProject


Views

# Defining a View Callable as a Function

	1 from pyramid.response import Response
	2
	3 def hello_world(request):
	4     return Response('Hello world!')

# Defining a View Callable as a Class

	Views defined as classes must have the following traits:
	• an __init__ method that accepts a request argument.
	• a __call__ (or other) method that accepts no parameters and which returns a response.

	1 from pyramid.response import Response
	2
	3 class MyView(object):
	4     def __init__(self, request):
	5         self.request = request
	6
	7     def __call__(self):
	8         return Response('hello')

	If you want to access "context", try "request.context"

# View Callable Responses

	1 from pyramid.response import Response
	2
	3 def view(request):
	4     return Response('OK')

	You don’t need to always use Response to represent a response like HTTPFound in pyramid.httpexceptions can be returned too. A view can actually return any object that has the following attributes.

	status: The HTTP status code (including the name) for the response as a string. E.g. 200 OK or 401 Unauthorized.
	headerlist: A sequence of tuples representing the list of headers that should be set in the response. E.g. [('Content-Type', 'text/html'), ('Content-Length', '412')]
	app_iter: An iterable representing the body of the response. This can be a list, e.g. ['<html><head></head><body>Hello world!</body></html>'] or it can be a file-like object, or any other sort of iterable.

# Using a View Callable to Do an HTTP Redirect

	You can issue an HTTP redirect from within a view by returning a particular kind of response.

	1 from pyramid.httpexceptions import HTTPFound
	2
	3 def myview(request):
	4     return HTTPFound(location='http://example.com')

	All exception types from the pyramid.httpexceptions module implement the Response interface; any can be returned as the response from a view.
	It also includes other response types that imply other HTTP response codes, such as HTTPUnauthorized for 401 Unauthorized.
					
# Using Special Exceptions In View Callables

	Usually when a Python exception is raised within a view callable, Except pyramid.exceptions.NotFound and pyramid.exceptions.Forbidden,
	Pyramid allows all the other exception to propagate all the way out to the WSGI server which invoked the application.
	The two special exceptions accept a single positional constructor argument: a message.
	If NotFound is raised within view code, the result of the Not Found View will be returned to the user agent which performed the request.
	If Forbidden is raised within view code, the result of the Forbidden View will be returned to the user agent which performed the request.
	In all cases, the message provided to the exception constructor is made available to the view which Pyramid invokes as request.exception.args[0].

# Exception Views

	For example, given the following exception class in a module named helloworld.exceptions:

	1 class ValidationFailure(Exception):
	2     def __init__(self, msg):
	3         self.msg = msg

	You can wire a view callable to be called whenever any of your other code raises a hellworld.exceptions.ValidationFailure exception:

	1 from helloworld.exceptions import ValidationFailure
	2
	3 @view_config(context=ValidationFailure)
	4 def failed_validation(exc, request):
	5     response =  Response('Failed validation: %s' % exc.msg)
	6     response.status_int = 500
	7     return response

	This view callable will be invoked whenever a helloworld.exceptions.ValidationError is raised by your application’s view code.

	Other normal view predicates can also be used in combination with an exception view registration:

	1 from pyramid.view import view_config
	2 from pyramid.exceptions import NotFound
	3 from pyramid.httpexceptions import HTTPNotFound
	4
	5 @view_config(context=NotFound, route_name='home')
	6 def notfound_view(request):
	7     return HTTPNotFound()

	The above exception view names the route_name of home, meaning that it will only be called when the route matched has a name of home.

# Handling Form Submissions in View Callables (Unicode and Character Set Issues)

	As an example, let’s assume that the following form page is served up to a browser client, and its action points at some Pyramid view code:

	1 <html xmlns="http://www.w3.org/1999/xhtml">
	2   <head>
	3     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	4   </head>
	5   <form method="POST" action="myview">
	6     <div>
	7       <input type="text" name="firstname"/>
	8     </div>
	9     <div>
	10       <input type="text" name="lastname"/>
	11     </div>
	12     <input type="submit" value="Submit"/>
	13   </form>
	14 </html>

	The values below in the request is converted from UTF-8 to Unicode implicitily.

	1 def myview(request):
	2     firstname = request.params['firstname']
	3     lastname = request.params['lastname']

	So make sure "charset=UTF-8" is always set in HTML head meta tag, otherwise this implicitily convertion will be failed.
	Since this implicitily convertion from UTF-8 to Unicode happens already, don't do this once again like: reqeust.params['firstname'].decode('utf-8')
	This convertion will happen only in reqeust.params, request.GET, request.POST
				 
Renderers






# Activate virtual python env first:
# source ~/mydevenv/bin/activate
#
# To create a new project named helloword and running it:
# $ paster create -t pylons StudyPylons
# cd StudyPylons
# $ paster serve --reload development.ini
# Visiting http://127.0.0.1:5000/ to see welcome page.
#
# To create a controller, this will produce a module which is located at studypylons/controllers/hello.py:
# $ paster controller hello
# Visiting http://127.0.0.1:5000/hello/index
#
# For SQLAlchemy:
#     0. "service mysql status" to make sure mysql is running.
#     1. Make sure you log into mysql console and run "CREATE DATABASE studypylons DEFAULT CHARACTER SET utf8;" first, and if it's a mysql on amazon ec2, 3306 port on ec2 should be exposed for outsider.
#     2. vi development.ini to add mysql db url.
#     3. Put model classes like person.py, address.py into studypylons/model/
#     4. Run "paster setup-app development.ini" to create the tables in the database, this command will call studypylons/websetup.py
#     5. Run "paster serve --reload development.ini"
# Visiting http://127.0.0.1:5000/person/index to see a sample for SQLAlchemy
#
# For unit testing:
# Run "nosetests" in "StudyPylons" folder to start unit testing, it will automatically run the test case in StudyPylons/studypylons/tests
#
# Using the model standalone:
# % python
# Python 2.5.1 (r251:54863, Oct 5 2007, 13:36:32)
# [GCC 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)] on linux2
# Type "help", "copyright", "credits" or "license" for more information.
# >>> import sqlalchemy as sa
# >>> engine = sa.create_engine("sqlite:///test.sqlite")
# >>> from studypylons.model import init_model, Person
# >>> from studypylons.model.meta import Session, Base
# >>> init_model(engine)
# >>> a = Person()
# >>> a.name = "Aaa"
# >>> a.email = "aaa@example.com"
# >>> Session.add(a)
# >>> Session.commit()
#
# For Generating the Production Configuration
# paster make-config studypylons production.ini
#
# Put set-up once objects for the entire application to config/environment.py or lib/app_globals __init__() method.
#
# Put custom middleware to config/middleware.py at comment marker:
# # CUSTOM MIDDLEWARE HERE (filtered by error hanlding middlewares)
#
# StudyPylons is a standard Python package which contains setup.py where defines the package dependencies
# To re-parse the setup.py line for new dependencies, run "$ python setup.py develop"
#
