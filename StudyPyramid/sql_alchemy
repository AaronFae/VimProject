SQLAlchemy ORM

[BEGIN: Object Relational Tutorial]

Version Check

	>>> import sqlalchemy
	>>> sqlalchemy.__version__
	0.6.0


Connecting

	>>> from sqlalchemy import create_engine
	>>> engine = create_engine('sqlite:///:memory:', echo=True)

	"echo=True" means generated SQL produced.

	Define and Create a Table:

	>>> from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey
	>>> metadata = MetaData()
	>>> users_table = Table('users', metadata,
	...     Column('id', Integer, primary_key=True),
	...     Column('name', String),
	...     Column('fullname', String),
	...     Column('password', String)
	... )

	Call create_all() and passing it the engine instance which points to our database to create table, this will check for the presence of a table first before creating, so it’s safe to call multiple times:

	sql>>> metadata.create_all(engine)
	PRAGMA table_info("users")
	()
	CREATE TABLE users (
		id INTEGER NOT NULL,
		name VARCHAR,
		fullname VARCHAR,
		password VARCHAR,
		PRIMARY KEY (id)
	)
	()
	COMMIT

	If you see issue when create table, it could be the target db requires "length" to the String type as below:
	Column('name', String(50))

	For oracle sequence:
	Column('id', Integer, Sequence('user_id_seq'), primary_key=True)


Define a Python Class to be Mapped

	>>> class User(object):
	...     def __init__(self, name, fullname, password):
	...         self.name = name
	...         self.fullname = fullname
	...         self.password = password
	...
	...     def __repr__(self):
	...        return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)


Setting up the Mapping

	>>> from sqlalchemy.orm import mapper
	>>> mapper(User, users_table)
		<Mapper at 0x...; User>

		The mapper() function creates a new Mapper object and stores it away for future
		reference, associated with our class. Let’s now create and inspect a User
		object:

		>>> ed_user = User('ed', 'Ed Jones', 'edspassword')
		>>> ed_user.name
		'ed'
		>>> ed_user.password
		'edspassword'
		>>> str(ed_user.id)
		'None'
		Since we have not yet told SQLAlchemy to persist Ed Jones within the database, its id is None. And User class doesn't define "id" attribute, but users_table does, so we have "id" here.


Creating Table, Class and Mapper All at Once Declaratively

	The steps above to create table, class and mapper could be simplized as below:

	>>> from sqlalchemy.ext.declarative import declarative_base

	>>> Base = declarative_base()
	>>> class User(Base):
	...     __tablename__ = 'users'
	...
	...     id = Column(Integer, primary_key=True)
	...     name = Column(String)
	...     fullname = Column(String)
	...     password = Column(String)
	...
	...     def __init__(self, name, fullname, password):
	...         self.name = name
	...         self.fullname = fullname
	...         self.password = password
	...
	...     def __repr__(self):
	...        return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)

	The underlying Table object created by our declarative_base() version of User is accessible via the __table__ attribute:

	>>> users_table = User.__table__

	The owning MetaData object is available as well:

	>>> metadata = Base.metadata


Creating a Session

	The ORM’s “handle” to the database is the Session.

	>>> from sqlalchemy.orm import sessionmaker
	>>> Session = sessionmaker(bind=engine)

	In the case where your application does not yet have an Engine when you define your module-level objects, just set it up like this:

	>>> Session = sessionmaker()

	Later, when you create your engine with create_engine(), connect it to the Session using configure():

	>>> Session.configure(bind=engine)  # once engine is available

	Then, whenever you need to have a conversation with the database, you instantiate a Session:

	>>> session = Session()

	The above Session is associated with our SQLite-enabled Engine, but it hasn’t opened any connections yet. When it’s first used, it retrieves a connection from a pool of connections maintained by the Engine, and holds onto it until we commit all changes and/or close the session object.


Adding new Objects

To persist our User object, we add() it to our Session:

	>>> ed_user = User('ed', 'Ed Jones', 'edspassword')
	>>> session.add(ed_user)

	At this point, we say that the instance is pending; no SQL has yet been issued and the object is not yet represented by a row in the database. The Session will issue the SQL to persist Ed Jones as soon as is needed, using a process known as a flush. If we query the database for Ed Jones, all pending information will first be flushed, and the query is issued immediately thereafter.

	For example, below we create a new Query object which loads instances of User. We “filter by” the name attribute of ed, and indicate that we’d like only the first result in the full list of rows. A User instance is returned which is equivalent to that which we’ve added:

	sql>>> our_user = session.query(User).filter_by(name='ed').first()
	BEGIN (implicit)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('ed', 'Ed Jones', 'edspassword')
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name = ?
	 LIMIT 1 OFFSET 0
	('ed',)
	>>> our_user
	<User('ed','Ed Jones', 'edspassword')>

	In fact, the Session has identified that the row returned is the same row as one already represented within its internal map of objects, so we actually got back the identical instance as that which we just added:

	>>> ed_user is our_user
	True

	We can add more User objects at once using add_all():

	>>> session.add_all([
	...     User('wendy', 'Wendy Williams', 'foobar'),
	...     User('mary', 'Mary Contrary', 'xxg527'),
	...     User('fred', 'Fred Flinstone', 'blah')])

	Also, Ed has already decided his password isn’t too secure, so lets change it:

	>>> ed_user.password = 'f8s7ccs'

	The Session is paying attention. It knows, for example, that Ed Jones has been modified:

	>>> session.dirty
	IdentitySet([<User('ed','Ed Jones', 'f8s7ccs')>])

	and that three new User objects are pending:

	>>> session.new
	IdentitySet([<User('wendy','Wendy Williams', 'foobar')>,
	<User('mary','Mary Contrary', 'xxg527')>,
	<User('fred','Fred Flinstone', 'blah')>])

	We tell the Session that we’d like to issue all remaining changes to the database and commit the
	transaction, which has been in progress throughout. We do this via commit():

	sql>>> session.commit()
	UPDATE users SET password=? WHERE users.id = ?
	('f8s7ccs', 1)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('wendy', 'Wendy Williams', 'foobar')
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('mary', 'Mary Contrary', 'xxg527')
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('fred', 'Fred Flinstone', 'blah')
	COMMIT

	commit() flushes whatever remaining changes remain to the database, and commits the transaction. The connection resources referenced by the session are now returned to the connection pool. Subsequent operations with this session will occur in a new transaction, which will again re-acquire connection resources when first needed.

	If we look at Ed’s id attribute, which earlier was None, it now has a value:

	sql>>> ed_user.id
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.id = ?
	(1,)
	1

	After the Session inserts new rows in the database, all newly generated identifiers and database-generated defaults become available on the instance, either immediately or via load-on-first-access. In this case, the entire row was re-loaded on access because a new transaction was begun after we issued commit(). SQLAlchemy by default refreshes data from a previous transaction the first time it’s accessed within a new transaction, so that the most recent state is available. The level of reloading is configurable as is described in the chapter on Sessions.


Rolling Back

	Since the Session works within a transaction, we can roll back changes made too. Let’s make two
changes that we’ll revert; ed_user‘s user name gets set to Edwardo:

	>>> ed_user.name = 'Edwardo'

	and we’ll add another erroneous user, fake_user:

	>>> fake_user = User('fakeuser', 'Invalid', '12345')
	>>> session.add(fake_user)

	Querying the session, we can see that they’re flushed into the current transaction:

	sql>>> session.query(User).filter(User.name.in_(['Edwardo', 'fakeuser'])).all()
	UPDATE users SET name=? WHERE users.id = ?
	('Edwardo', 1)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('fakeuser', 'Invalid', '12345')
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name IN (?, ?)
	('Edwardo', 'fakeuser')
	[<User('Edwardo','Ed Jones', 'f8s7ccs')>, <User('fakeuser','Invalid', '12345')>]

	Rolling back, we can see that ed_user‘s name is back to ed, and fake_user has been kicked out of the session:

	sql>>> session.rollback()
	ROLLBACK

	sql>>> ed_user.name
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.id = ?
	(1,)
	u'ed'
	>>> fake_user in session
	False


Querying

	1. Query class, return a list of users:

	sql>>> for instance in session.query(User).order_by(User.id):
	...     print instance.name, instance.fullname
	SELECT users.id AS users_id, users.name AS users_name,
	users.fullname AS users_fullname, users.password AS users_password
	FROM users ORDER BY users.id
	()
	ed Ed Jones
	wendy Wendy Williams
	mary Mary Contrary
	fred Fred Flinstone

	2. Query fields on class, return a tuples:

	sql>>> for name, fullname in session.query(User.name, User.fullname):
	...     print name, fullname
	SELECT users.name AS users_name, users.fullname AS users_fullname
	FROM users
	()
	ed Ed Jones
	wendy Wendy Williams
	mary Mary Contrary
	fred Fred Flinstone

	3. The tuples returned by Query are named tuples, and can be treated much like an ordinary Python object.

	sql>>> for row in session.query(User, User.name).all():
	...    print row.User, row.name

	4.  You can control the names using the label() construct for scalar attributes and aliased for class constructs:
	>>> from sqlalchemy.orm import aliased
	>>> user_alias = aliased(User, name='user_alias')
	sql>>> for row in session.query(user_alias, user_alias.name.label('name_label')).all():
	...    print row.user_alias, row.name_label
	It has the same side effective with the point 3 above, but with alias class and attribute.

	5. LIMIT and OFFSET, with ORDER BY:

	sql>>> for u in session.query(User).order_by(User.id)[1:3]:
	...    print u
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users ORDER BY users.id
	LIMIT 2 OFFSET 1
	()
	<User('wendy','Wendy Williams', 'foobar')>
	<User('mary','Mary Contrary', 'xxg527')>

	6. Filtering results: 

	sql>>> for name, in session.query(User.name).filter_by(fullname='Ed Jones'):
	...    print name
	SELECT users.name AS users_name FROM users
	WHERE users.fullname = ?
	('Ed Jones',)
	e

	sql>>> for name, in session.query(User.name).filter(User.fullname=='Ed Jones'):
	...    print name
	SELECT users.name AS users_name FROM users
	WHERE users.fullname = ?
	('Ed Jones',)
	ed

	sql>>> for user in session.query(User).filter(User.name=='ed').filter(User.fullname=='Ed Jones'):
	...    print user
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name = ? AND users.fullname = ?
	('ed', 'Ed Jones')
	<User('ed','Ed Jones', 'f8s7ccs')>


Common Filter Operators

	Here’s a rundown of some of the most common operators used in filter():

	• equals:

	query.filter(User.name == 'ed')

	• not equals:

	query.filter(User.name != 'ed')

	• LIKE:

	query.filter(User.name.like('%ed%'))

	• IN:

	query.filter(User.name.in_(['ed', 'wendy', 'jack']))

	# works with query objects too:

	query.filter(User.name.in_(session.query(User.name).filter(User.name.like('%ed%'))))

	• NOT IN:

	query.filter(~User.name.in_(['ed', 'wendy', 'jack']))

	• IS NULL:

	filter(User.name == None)

	• IS NOT NULL:

	filter(User.name != None)

	• AND:

	from sqlalchemy import and_
	filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))

	# or call filter()/filter_by() multiple times
	filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')

	• OR:

	from sqlalchemy import or_
	filter(or_(User.name == 'ed', User.name == 'wendy'))

	• match:

	query.filter(User.name.match('wendy'))

	The contents of the match parameter are database backend specific.


Returning Lists and Scalars

	The all(), one(), and first() methods of Query immediately issue SQL and return a non-iterator value. all() returns a list:

	1. 
	>>> query = session.query(User).filter(User.name.like('%ed')).order_by(User.id)
	sql>>> query.all()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fu
	FROM users
	WHERE users.name LIKE ? ORDER BY users.id
	('%ed',)
	[<User('ed','Ed Jones', 'f8s7ccs')>, <User('fred','Fred Flinstone', 'blah')>]

	2. 
	first() applies a limit of one and returns the first result as a scalar:

	sql>>> query.first()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fu
	FROM users
	WHERE users.name LIKE ? ORDER BY users.id
	LIMIT 1 OFFSET 0
	('%ed',)
	<User('ed','Ed Jones', 'f8s7ccs')>

	3.
	one(), fully fetches all rows, and if not exactly one object identity or composite row is present in the result, raises an error:

	sql>>> from sqlalchemy.orm.exc import MultipleResultsFound
	>>> try:
	...     user = query.one()
	... except MultipleResultsFound, e:
	...     print e
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fu
	FROM users
	WHERE users.name LIKE ? ORDER BY users.id
	('%ed',)
	Multiple rows were found for one()

	sql>>> from sqlalchemy.orm.exc import NoResultFound
	>>> try:
	...     user = query.filter(User.id == 99).one()
	... except NoResultFound, e:
	...     print e
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS user
	FROM users
	WHERE users.name LIKE ? AND users.id = ? ORDER BY users.id
	('%ed', 99)
	No row was found for one()


Using Literal SQL

	1.  Most methods accept strings in addition to SQLAlchemy clause constructs. For example, filter() and order_by():

	sql>>> for user in session.query(User).filter("id<224").order_by("id").all():
	...     print user.name
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE id<224 ORDER BY id
	()
	ed
	wendy
	mary
	fred

	2. Bind parameters can be specified with string-based SQL, using a colon. To specify the values, use the params() method:

	sql>>> session.query(User).filter("id<:value and name=:name").\
	...     params(value=224, name='fred').order_by(User.id).one()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE id<User('fred','Fred Flinstone', 'blah')>

	3. To use an entirely string-based statement:

	sql>>> session.query(User).from_statement(
	...                     "SELECT * FROM users where name=:name").\
	...                     params(name='ed').all()
	SELECT * FROM users where name=?
	('ed',)
	[<User('ed','Ed Jones', 'f8s7ccs')>]

	4. You can use from_statement() to go completely “raw”, using string names to identify desired columns:

	sql>>> session.query("id", "name", "thenumber12").\
	...         from_statement("SELECT id, name, 12 as "
	...                 "thenumber12 FROM users where name=:name").\
	...                 params(name='ed').all()
	SELECT id, name, 12 as thenumber12 FROM users where name=?
	('ed',)
	[(1, u'ed', 12)]


Counting

	1. For simple count: Query includes a convenience method for counting called count():

	sql>>> session.query(User).filter(User.name.like('%ed')).count()
	SELECT count(1) AS count_1
	FROM users
	WHERE users.name LIKE ?
	('%ed',)
	2

	2. For more complicated count:

	Use the func.count() function as a column expression:

	>>> from sqlalchemy import func
	sql>>> session.query(func.count(User.name), User.name).group_by(User.name).all()
	SELECT count(users.name) AS count_1, users.name AS users_name
	FROM users GROUP BY users.name
	()
	[(1, u'ed'), (1, u'fred'), (1, u'mary'), (1, u'wendy')]


Building a Relationship

	Using declarative, we define this table along with its mapped class, Address:

	>>> from sqlalchemy import ForeignKey
	>>> from sqlalchemy.orm import relationship, backref
	>>> class Address(Base):
	...
	...     __tablename__ = 'addresses'
	...
	...     id = Column(Integer, primary_key=True)
	...     email_address = Column(String, nullable=False)
	...     user_id = Column(Integer, ForeignKey('users.id'))
	...
	...     user = relationship(User, backref=backref('addresses', order_by=id))
	...
	...     def __init__(self, email_address):
	...         self.email_address = email_address
	...
	...     def __repr__(self):
	...         return "<Address('%s')>" % self.email_address

	The relationship between the User and Address classes is defined separately using the relationship() function, which defines an attribute user to be placed on the Address class, as well as an addresses collection to be placed on the User class. SQLAlchemy is automatically aware of many-to-one/one-to-many based on foreign keys.

	class User(Base):
	# ....
	addresses = relationship(Address, order_by=Address.id, backref="user")

	[We are also free to not define a backref, and to define the relationship() only on one class and not the other.](means if you don't have to set backref in class Address, you don't have to have "addresses" defined in class User) It is also possible to define two separate relationship() constructs for either direction, which is generally safe for many-to-one and one-to-many relationships, but not for many-to-many relationships.

	When using the declarative extension, relationship() gives us the option to use strings for most arguments that concern the target class, in the case that the target class has not yet been defined. This only works in conjunction with declarative:

	class User(Base):
	....
	addresses = relationship("Address", order_by="Address.id", backref="user")

	We’ll need to create the addresses table in the database, so we will issue another CREATE from our metadata, which will skip over tables which have already
	been created:

	sql>>> metadata.create_all(engine)
	PRAGMA table_info("users")
	()
	PRAGMA table_info("addresses")
	()
	CREATE TABLE addresses (
	id INTEGER NOT NULL,
	email_address VARCHAR NOT NULL,
	user_id INTEGER,
	PRIMARY KEY (id),
	FOREIGN KEY(user_id) REFERENCES users (id)
	)
	()
	COMMIT


Working with Related Objects

	>>> jack = User('jack', 'Jack Bean', 'gjffdd')
	>>> jack.addresses
	[]

	>>> jack.addresses = [Address(email_address='jack@google.com'), Address(email_address='j25@yahoo.com')]

	When using a bidirectional relationship, elements added in one direction automatically become visible in the other direction. This is the basic behavior of the backref keyword, which maintains the relationship purely in memory, without using any SQL:

	>>> jack.addresses[1]
	<Address('j25@yahoo.com')>

	>>> jack.addresses[1].user
	<User('jack','Jack Bean', 'gjffdd')>

	>>> session.add(jack)
	sql>>> session.commit()
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('jack', 'Jack Bean', 'gjffdd')
	INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
	('jack@google.com', 5)
	INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
	('j25@yahoo.com', 5)
	COMMIT

	Querying for Jack, we get just Jack back. No SQL is yet issued for Jack’s addresses:

	sql>>> jack = session.query(User).filter_by(name='jack').one()
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE users.name = ?
	('jack',)
	>>> jack
	<User('jack','Jack Bean', 'gjffdd')>

	sql>>> jack.addresses
	SELECT addresses.id AS addresses_id, addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id
	FROM addresses
	WHERE ? = addresses.user_id ORDER BY addresses.id
	(5,)
	[<Address('jack@google.com')>, <Address('j25@yahoo.com')>]

	This is an example of a lazy loading relationship.

	To reduce the number of queries, apply an eager load to the query operation, using the joinedload() function.
	SQLAlchemy then constructs an outer join between the users and addresses tables, and loads them at once, populating the addresses collection on each User object if it’s not already populated:

	>>> from sqlalchemy.orm import joinedload

	sql>>> jack = session.query(User).\
	...                        options(joinedload('addresses')).\
	...                        filter_by(name='jack').one()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname,
	users.password AS users_password, addresses_1.id AS addresses_1_id, addresses_1.email_address
	AS addresses_1_email_address, addresses_1.user_id AS addresses_1_user_id
	FROM users LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id
	WHERE users.name = ? ORDER BY addresses_1.id
	('jack',)
	>>> jack
	<User('jack','Jack Bean', 'gjffdd')>

	>>> jack.addresses
	[<Address('jack@google.com')>, <Address('j25@yahoo.com')>]

	Check out joinedload() and subqueryload() in documentation.


Querying with Joins

	While joinedload() created a JOIN specifically to populate a collection, we can also work explicitly with joins in many ways.

	sql>>> for u, a in session.query(User, Address).filter(User.id==Address.user_id).\
	...         filter(Address.email_address=='jack@google.com').all():
	...     print u, a
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname,
	users.password AS users_password, addresses.id AS addresses_id,
	addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id
	FROM users, addresses
	WHERE users.id = addresses.user_id AND addresses.email_address = ?
	('jack@google.com',)
	<User('jack','Jack Bean', 'gjffdd')> <Address('jack@google.com')>

	Or we can make a real JOIN construct; the most common way is to use join():

	sql>>> session.query(User).join(Address).\
	...         filter(Address.email_address=='jack@google.com').all()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users JOIN addresses ON users.id = addresses.user_id
	WHERE addresses.email_address = ?
	('jack@google.com',)
	[<User('jack','Jack Bean', 'gjffdd')>]

	join() knows how to join between User and Address because there’s only one foreign key between them.
	If there were no foreign keys, or several, join() works better when one of the following forms are used:

	query.join((Address, User.id==Address.user_id))  # explicit condition (note the tuple)
	query.join(User.addresses)                       # specify relationship from left to right
	query.join((Address, User.addresses))            # same, with explicit target
	query.join('addresses')                          # same, using a string

	Note that when join() is called with an explicit target as well as an ON clause, we use a tuple as the argument. This is so that multiple joins can be chained together, as in:

	session.query(Foo).join(
	Foo.bars,
	(Bat, bar.bats),
	(Widget, Bat.widget_id==Widget.id)
	)

	The above would produce SQL something like foo JOIN bars ON <onclause> JOIN bats ON <onclause> JOIN widgets ON <onclause>.

	The general functionality of join() is also available as a standalone function join(), which is an ORM-enabled version of the same function present in the
	SQL expression language. This function accepts two or three arguments (left side, right side, optional ON clause) and can be used in conjunction with the
	select_from() method to set an explicit FROM clause:

