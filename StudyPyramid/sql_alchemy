SQLAlchemy ORM

[BEGIN: Object Relational Tutorial]

Version Check

	>>> import sqlalchemy
	>>> sqlalchemy.__version__
	0.6.0


Connecting

	>>> from sqlalchemy import create_engine
	>>> engine = create_engine('sqlite:///:memory:', echo=True)

	"echo=True" means generated SQL produced.

	Define and Create a Table:

	>>> from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey
	>>> metadata = MetaData()
	>>> users_table = Table('users', metadata,
	...     Column('id', Integer, primary_key=True),
	...     Column('name', String),
	...     Column('fullname', String),
	...     Column('password', String)
	... )

	Call create_all() and passing it the engine instance which points to our database to create table, this will check for the presence of a table first before creating, so it’s safe to call multiple times:

	sql>>> metadata.create_all(engine)
	PRAGMA table_info("users")
	()
	CREATE TABLE users (
		id INTEGER NOT NULL,
		name VARCHAR,
		fullname VARCHAR,
		password VARCHAR,
		PRIMARY KEY (id)
	)
	()
	COMMIT

	If you see issue when create table, it could be the target db requires "length" to the String type as below:
	Column('name', String(50))

	For oracle sequence:
	Column('id', Integer, Sequence('user_id_seq'), primary_key=True)


Define a Python Class to be Mapped

	>>> class User(object):
	...     def __init__(self, name, fullname, password):
	...         self.name = name
	...         self.fullname = fullname
	...         self.password = password
	...
	...     def __repr__(self):
	...        return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)


Setting up the Mapping

	>>> from sqlalchemy.orm import mapper
	>>> mapper(User, users_table)
		<Mapper at 0x...; User>

		The mapper() function creates a new Mapper object and stores it away for future
		reference, associated with our class. Let’s now create and inspect a User
		object:

		>>> ed_user = User('ed', 'Ed Jones', 'edspassword')
		>>> ed_user.name
		'ed'
		>>> ed_user.password
		'edspassword'
		>>> str(ed_user.id)
		'None'
		Since we have not yet told SQLAlchemy to persist Ed Jones within the database, its id is None. And User class doesn't define "id" attribute, but users_table does, so we have "id" here.


Creating Table, Class and Mapper All at Once Declaratively

	The steps above to create table, class and mapper could be simplized as below:

	>>> from sqlalchemy.ext.declarative import declarative_base

	>>> Base = declarative_base()
	>>> class User(Base):
	...     __tablename__ = 'users'
	...
	...     id = Column(Integer, primary_key=True)
	...     name = Column(String)
	...     fullname = Column(String)
	...     password = Column(String)
	...
	...     def __init__(self, name, fullname, password):
	...         self.name = name
	...         self.fullname = fullname
	...         self.password = password
	...
	...     def __repr__(self):
	...        return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)

	The underlying Table object created by our declarative_base() version of User is accessible via the __table__ attribute:

	>>> users_table = User.__table__

	The owning MetaData object is available as well:

	>>> metadata = Base.metadata


Creating a Session

	The ORM’s “handle” to the database is the Session.

	>>> from sqlalchemy.orm import sessionmaker
	>>> Session = sessionmaker(bind=engine)

	In the case where your application does not yet have an Engine when you define your module-level objects, just set it up like this:

	>>> Session = sessionmaker()

	Later, when you create your engine with create_engine(), connect it to the Session using configure():

	>>> Session.configure(bind=engine)  # once engine is available

	Then, whenever you need to have a conversation with the database, you instantiate a Session:

	>>> session = Session()

	The above Session is associated with our SQLite-enabled Engine, but it hasn’t opened any connections yet. When it’s first used, it retrieves a connection from a pool of connections maintained by the Engine, and holds onto it until we commit all changes and/or close the session object.


Adding new Objects

To persist our User object, we add() it to our Session:

	>>> ed_user = User('ed', 'Ed Jones', 'edspassword')
	>>> session.add(ed_user)

	At this point, we say that the instance is pending; no SQL has yet been issued and the object is not yet represented by a row in the database. The Session will issue the SQL to persist Ed Jones as soon as is needed, using a process known as a flush. If we query the database for Ed Jones, all pending information will first be flushed, and the query is issued immediately thereafter.

	For example, below we create a new Query object which loads instances of User. We “filter by” the name attribute of ed, and indicate that we’d like only the first result in the full list of rows. A User instance is returned which is equivalent to that which we’ve added:

	sql>>> our_user = session.query(User).filter_by(name='ed').first()
	BEGIN (implicit)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('ed', 'Ed Jones', 'edspassword')
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name = ?
	 LIMIT 1 OFFSET 0
	('ed',)
	>>> our_user
	<User('ed','Ed Jones', 'edspassword')>

	In fact, the Session has identified that the row returned is the same row as one already represented within its internal map of objects, so we actually got back the identical instance as that which we just added:

	>>> ed_user is our_user
	True

	We can add more User objects at once using add_all():

	>>> session.add_all([
	...     User('wendy', 'Wendy Williams', 'foobar'),
	...     User('mary', 'Mary Contrary', 'xxg527'),
	...     User('fred', 'Fred Flinstone', 'blah')])

	Also, Ed has already decided his password isn’t too secure, so lets change it:

	>>> ed_user.password = 'f8s7ccs'

	The Session is paying attention. It knows, for example, that Ed Jones has been modified:

	>>> session.dirty
	IdentitySet([<User('ed','Ed Jones', 'f8s7ccs')>])

	and that three new User objects are pending:

	>>> session.new
	IdentitySet([<User('wendy','Wendy Williams', 'foobar')>,
	<User('mary','Mary Contrary', 'xxg527')>,
	<User('fred','Fred Flinstone', 'blah')>])

	We tell the Session that we’d like to issue all remaining changes to the database and commit the
	transaction, which has been in progress throughout. We do this via commit():

	sql>>> session.commit()
	UPDATE users SET password=? WHERE users.id = ?
	('f8s7ccs', 1)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('wendy', 'Wendy Williams', 'foobar')
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('mary', 'Mary Contrary', 'xxg527')
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('fred', 'Fred Flinstone', 'blah')
	COMMIT

	commit() flushes whatever remaining changes remain to the database, and commits the transaction. The connection resources referenced by the session are now returned to the connection pool. Subsequent operations with this session will occur in a new transaction, which will again re-acquire connection resources when first needed.

	If we look at Ed’s id attribute, which earlier was None, it now has a value:

	sql>>> ed_user.id
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.id = ?
	(1,)
	1

	After the Session inserts new rows in the database, all newly generated identifiers and database-generated defaults become available on the instance, either immediately or via load-on-first-access. In this case, the entire row was re-loaded on access because a new transaction was begun after we issued commit(). SQLAlchemy by default refreshes data from a previous transaction the first time it’s accessed within a new transaction, so that the most recent state is available. The level of reloading is configurable as is described in the chapter on Sessions.


Rolling Back

	Since the Session works within a transaction, we can roll back changes made too. Let’s make two
changes that we’ll revert; ed_user‘s user name gets set to Edwardo:

	>>> ed_user.name = 'Edwardo'

	and we’ll add another erroneous user, fake_user:

	>>> fake_user = User('fakeuser', 'Invalid', '12345')
	>>> session.add(fake_user)

	Querying the session, we can see that they’re flushed into the current transaction:

	sql>>> session.query(User).filter(User.name.in_(['Edwardo', 'fakeuser'])).all()
	UPDATE users SET name=? WHERE users.id = ?
	('Edwardo', 1)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('fakeuser', 'Invalid', '12345')
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name IN (?, ?)
	('Edwardo', 'fakeuser')
	[<User('Edwardo','Ed Jones', 'f8s7ccs')>, <User('fakeuser','Invalid', '12345')>]

	Rolling back, we can see that ed_user‘s name is back to ed, and fake_user has been kicked out of the session:

	sql>>> session.rollback()
	ROLLBACK

	sql>>> ed_user.name
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.id = ?
	(1,)
	u'ed'
	>>> fake_user in session
	False


Querying

	1. Query class, return a list of users:

	sql>>> for instance in session.query(User).order_by(User.id):
	...     print instance.name, instance.fullname
	SELECT users.id AS users_id, users.name AS users_name,
	users.fullname AS users_fullname, users.password AS users_password
	FROM users ORDER BY users.id
	()
	ed Ed Jones
	wendy Wendy Williams
	mary Mary Contrary
	fred Fred Flinstone

	2. Query fields on class, return a tuples:

	sql>>> for name, fullname in session.query(User.name, User.fullname):
	...     print name, fullname
	SELECT users.name AS users_name, users.fullname AS users_fullname
	FROM users
	()
	ed Ed Jones
	wendy Wendy Williams
	mary Mary Contrary
	fred Fred Flinstone

	3. The tuples returned by Query are named tuples, and can be treated much like an ordinary Python object.

	sql>>> for row in session.query(User, User.name).all():
	...    print row.User, row.name

	4.  You can control the names using the label() construct for scalar attributes and aliased for class constructs:
	>>> from sqlalchemy.orm import aliased
	>>> user_alias = aliased(User, name='user_alias')
	sql>>> for row in session.query(user_alias, user_alias.name.label('name_label')).all():
	...    print row.user_alias, row.name_label
	It has the same side effective with the point 3 above, but with alias class and attribute.

	5. LIMIT and OFFSET, with ORDER BY:

	sql>>> for u in session.query(User).order_by(User.id)[1:3]:
	...    print u
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users ORDER BY users.id
	LIMIT 2 OFFSET 1
	()
	<User('wendy','Wendy Williams', 'foobar')>
	<User('mary','Mary Contrary', 'xxg527')>

	6. Filtering results: 

	sql>>> for name, in session.query(User.name).filter_by(fullname='Ed Jones'):
	...    print name
	SELECT users.name AS users_name FROM users
	WHERE users.fullname = ?
	('Ed Jones',)
	e

	sql>>> for name, in session.query(User.name).filter(User.fullname=='Ed Jones'):
	...    print name
	SELECT users.name AS users_name FROM users
	WHERE users.fullname = ?
	('Ed Jones',)
	ed

	sql>>> for user in session.query(User).filter(User.name=='ed').filter(User.fullname=='Ed Jones'):
	...    print user
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name = ? AND users.fullname = ?
	('ed', 'Ed Jones')
	<User('ed','Ed Jones', 'f8s7ccs')>


Common Filter Operators

	Here’s a rundown of some of the most common operators used in filter():

	• equals:

	query.filter(User.name == 'ed')

	• not equals:

	query.filter(User.name != 'ed')

	• LIKE:

	query.filter(User.name.like('%ed%'))

	• IN:

	query.filter(User.name.in_(['ed', 'wendy', 'jack']))

	# works with query objects too:

	query.filter(User.name.in_(session.query(User.name).filter(User.name.like('%ed%'))))

	• NOT IN:

	query.filter(~User.name.in_(['ed', 'wendy', 'jack']))

	• IS NULL:

	filter(User.name == None)

	• IS NOT NULL:

	filter(User.name != None)

	• AND:

	from sqlalchemy import and_
	filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))

	# or call filter()/filter_by() multiple times
	filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')

	• OR:

	from sqlalchemy import or_
	filter(or_(User.name == 'ed', User.name == 'wendy'))

	• match:

	query.filter(User.name.match('wendy'))

	The contents of the match parameter are database backend specific.


